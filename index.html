<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Eco-Town Legend EX - Mobile Base</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=DotGothic16&display=swap');

    :root {
      --primary-bg: #050505;
      --panel-bg: rgba(20, 20, 20, 0.9);
      --border-color: #ffffff;
    }

    body {
      background-color: var(--primary-bg);
      color: #fff;
      font-family: 'DotGothic16', sans-serif;
      margin: 0;
      overflow: hidden;
      touch-action: manipulation;
    }

    /* âœ… iPhone Safariã®ä¸‹ãƒãƒ¼å¯¾ç­–ï¼šsafe-areaä¸‹ä½™ç™½ */
    .safe-bottom {
      padding-bottom: env(safe-area-inset-bottom);
    }

    .app-container {
      width: 100vw;
      /* âœ… 100vhã¯iPhone Safariã§ã‚ºãƒ¬ã‚‹ã®ã§innerHeightå®Ÿæ¸¬ã«ã™ã‚‹ */
      height: var(--app-h, 100vh);
      display: flex;
      flex-direction: column;
      max-width: 500px;
      margin: 0 auto;
      border-left: 1px solid #333;
      border-right: 1px solid #333;
    }

    .btn-action {
      background: #222;
      border: 2px solid var(--border-color);
      padding: 12px 8px;
      text-align: center;
      font-size: 14px;
      cursor: pointer;
      transition: transform 0.1s, background 0.1s;
    }
    .btn-action:active:not(.disabled) {
      transform: scale(0.95);
      background: #fff;
      color: #000;
    }
    .disabled {
      opacity: 0.3;
      pointer-events: none;
      filter: grayscale(1);
    }

    .stat-bar {
      height: 12px;
      background: #111;
      border: 1px solid #444;
      border-radius: 6px;
      overflow: hidden;
    }

    #game-canvas {
      image-rendering: pixelated;
      width: 100%;
      background: #0a0a0a;
      flex-shrink: 0;
      display: block;
    }

    .ad-placeholder {
      background: #1a1a1a;
      color: #444;
      height: 50px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      border-top: 1px solid #333;
    }

    .floating-text {
      position: absolute;
      animation: floatUp 1.2s ease-out forwards;
      pointer-events: none;
      font-weight: bold;
      font-size: 16px;
      z-index: 100;
      text-shadow: 2px 2px #000;
    }
    @keyframes floatUp {
      0% { transform: translateY(0); opacity: 1; }
      100% { transform: translateY(-60px); opacity: 0; }
    }

    .tab-content { display: none; height: 100%; overflow-y: auto; }
    .tab-content.active { display: block; }

    #custom-modal {
      display: none;
      position: absolute;
      inset: 0;
      background: rgba(0,0,0,0.8);
      z-index: 1000;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    .hint-banner {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      bottom: 8px;
      background: rgba(0,0,0,0.75);
      border: 1px solid rgba(255,255,255,0.35);
      padding: 6px 10px;
      font-size: 10px;
      z-index: 30;
      pointer-events: none;
      white-space: nowrap;
    }

    .asset-status {
      position: absolute;
      top: 8px;
      right: 8px;
      background: rgba(0,0,0,0.70);
      border: 1px solid rgba(255,255,255,0.35);
      padding: 4px 6px;
      font-size: 9px;
      z-index: 25;
      pointer-events: none;
      line-height: 1.25;
      text-align: right;
      white-space: nowrap;
    }
  </style>
</head>

<body>
  <div class="app-container">
    <!-- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒãƒ¼ -->
    <div class="grid grid-cols-3 gap-1 p-2 bg-black border-b-2 border-white text-[10px]">
      <div class="text-center">
        <div class="text-gray-400">è³‡é‡‘</div>
        <div class="text-yellow-400 font-bold text-sm"><span id="ui-money">0</span> G</div>
      </div>
      <div class="text-center border-x border-gray-800">
        <div class="text-gray-400">äººå£</div>
        <div class="text-white font-bold text-sm" id="ui-pop">100</div>
      </div>
      <div class="text-center">
        <div class="text-gray-400">ã‚´ãƒŸ</div>
        <div class="text-red-400 font-bold text-sm" id="ui-waste">0.0</div>
      </div>
    </div>

    <!-- ãƒ¡ã‚¤ãƒ³ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ«ï¼ˆCanvasï¼‰ -->
    <div class="relative overflow-hidden bg-black" id="screen-container">
      <canvas id="game-canvas"></canvas>

      <!-- âœ… ä¸–ç•Œå´©å£Šãƒ•ã‚§ãƒ¼ã‚ºãƒ»ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ï¼ˆã‚­ãƒ£ãƒ³ã‚»ãƒ«ä¸å¯æ¼”å‡ºï¼‰ -->
      <div id="collapse-overlay" style="display:none; position:absolute; inset:0; z-index:2000; background:rgba(0,0,0,0.92); align-items:center; justify-content:center; padding:18px;">
        <div class="bg-black/80 border-2 border-red-500 p-4 w-full max-w-sm text-center space-y-3">
          <div class="text-red-400 font-bold text-sm">âš  ä¸–ç•Œå´©å£Šãƒ•ã‚§ãƒ¼ã‚º</div>
          <div id="collapse-text" class="text-[11px] text-gray-200 leading-relaxed">
            å´©å£ŠãŒå§‹ã¾ã‚Šã¾ã—ãŸã€‚<br>
            ç’°å¢ƒãƒ»æ²»å®‰ãƒ»å¥åº·ãŒæ€¥æ¿€ã«æ‚ªåŒ–ã—ã¾ã™ã€‚<br>
            ç«‹ã¦ç›´ã›ã‚‹ã‹ã©ã†ã‹ã€ä»Šã“ã“ã‹ã‚‰ã§ã™ã€‚
          </div>
          <div class="text-[10px] text-gray-400">
            â€»ã“ã®è­¦å‘Šã¯é–‰ã˜ã‚‰ã‚Œã¾ã›ã‚“ï¼ˆçªå…¥æ¼”å‡ºï¼‰
          </div>
        </div>
      </div>

      <!-- 4ã‚¹ãƒ† -->
      <div class="absolute top-2 left-2 bg-black/70 p-1 border border-white/50 text-[9px] z-20">
        ATK:<span id="st-atk">0</span>
        DEF:<span id="st-def">0</span>
        SPD:<span id="st-spd">0</span>
        LUK:<span id="st-luk">0</span>
      </div>

      <div class="asset-status" id="asset-status">ASSET: ...</div>

      <div id="place-hint" class="hint-banner hidden">
        æ–½è¨­ã‚’ç½®ãå ´æ‰€ã‚’ã‚¿ãƒƒãƒ—ï¼ˆé“è·¯ã«ã¯ç½®ã‘ã¾ã›ã‚“ï¼‰
      </div>
    </div>

    <!-- ãƒãƒˆãƒ«HUD -->
    <div id="battle-hud" class="hidden bg-black/90 border-t border-white/20 p-2 space-y-2">
      <div class="border-2 border-red-500 p-2 bg-black/80">
        <div id="enemy-name" class="text-xs text-red-500 font-bold mb-1 text-center">MONSTER</div>
        <div class="stat-bar">
          <div id="enemy-hp-bar" class="bg-red-600 h-full w-full transition-all duration-300"></div>
        </div>
        <div id="enemy-hp-text" class="text-[10px] text-white mt-1 text-center">0/0</div>
      </div>

      <div class="border-2 border-blue-500 p-2 bg-black/80">
        <div class="text-[10px] text-blue-400 font-bold mb-1 text-center">PLAYER HP</div>
        <div class="stat-bar">
          <div id="battle-player-hp-bar" class="bg-green-500 h-full w-full transition-all duration-300"></div>
        </div>
        <div id="battle-player-hp-text" class="text-[10px] text-white mt-1 text-center">100/100</div>
      </div>
    </div>

    <!-- ãƒ­ã‚° -->
    <div id="msg-layer" class="w-full bg-black/80 p-2 text-[11px] border-t border-white/30 h-12 flex items-center">
      <div id="game-log">é å¾ã®æº–å‚™ã‚’ã—ã¾ã—ã‚‡ã†ã€‚</div>
    </div>

    <!-- ç’°å¢ƒã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ -->
    <div class="p-2 bg-gray-900 grid grid-cols-3 gap-2 text-[9px] border-b border-white/20">
      <div>
        ğŸŒ ç’°å¢ƒ <span id="val-env">80</span>%
        <div class="stat-bar"><div id="bar-env" class="bg-green-500 h-full"></div></div>
      </div>
      <div>
        âš–ï¸ æ²»å®‰ <span id="val-sec">80</span>%
        <div class="stat-bar"><div id="bar-sec" class="bg-blue-500 h-full"></div></div>
      </div>
      <div>
        ğŸ’Š å¥åº· <span id="val-heal">80</span>%
        <div class="stat-bar"><div id="bar-heal" class="bg-red-500 h-full"></div></div>
      </div>
    </div>

    <!-- ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ -->
    <div class="flex-grow bg-black p-3 relative overflow-hidden">
      <!-- è¡— -->
      <div id="tab-town" class="tab-content active space-y-3">
        <div class="text-[11px] text-gray-200 border border-white/20 p-2">
          ğŸ§¹ æ¸…æƒåŠ›ï¼š<span id="ui-clean">0.0</span> / ç§’ï¼ˆæ¸…æƒå“¡ <span id="ui-staff">0</span> äººï¼‰
        </div>

        <button onclick="buyUpgrade('park')" class="btn-action w-full flex justify-between items-center">
          <span>â›² å…¬åœ’æ•´å‚™ï¼ˆç’°å¢ƒ+ï¼‰</span><span class="text-yellow-400">1,000G</span>
        </button>
        <button onclick="startPatrol()" class="btn-action w-full flex justify-between items-center">
          <span>ğŸš¶ ãƒ‘ãƒˆãƒ­ãƒ¼ãƒ«ï¼ˆæ²»å®‰+ / ä¸€å®šæ™‚é–“ãƒ–ãƒ¼ã‚¹ãƒˆï¼‰</span>
          <span class="text-yellow-400" id="patrol-cost">400G</span>
        </button>
        <button onclick="buyUpgrade('medical')" class="btn-action w-full flex justify-between items-center">
          <span>ğŸ’Š åŒ»ç™‚æŠ•è³‡ï¼ˆå¥åº·+ï¼‰</span><span class="text-yellow-400">2,500G</span>
        </button>

        <button onclick="selectFacilityToPlace('hospital')" class="btn-action w-full flex justify-between items-center">
          <span>ğŸ¥ ç—…é™¢ è¨­ç½®ï¼ˆæœ€å¤§5ï¼‰</span><span class="text-yellow-400">2,500G</span>
        </button>
        <button onclick="selectFacilityToPlace('police')" class="btn-action w-full flex justify-between items-center">
          <span>ğŸš“ è­¦å¯Ÿç½² è¨­ç½®</span><span class="text-yellow-400">6,000G</span>
        </button>
        <button onclick="selectFacilityToPlace('fire')" class="btn-action w-full flex justify-between items-center">
          <span>ğŸš’ æ¶ˆé˜²ç½² è¨­ç½®</span><span class="text-yellow-400">6,000G</span>
        </button>
        <button onclick="recruitStaff()" class="btn-action w-full flex justify-between items-center">
          <span>ğŸ§¹ æ¸…æƒå“¡é›‡ç”¨</span><span class="text-yellow-400" id="staff-cost">300G</span>
        </button>

        <div class="text-[10px] text-gray-300 border border-white/10 p-2">
          âœ… æ–½è¨­ã¯ã€Œå¥½ããªä½ç½®ã€ã«ç½®ã‘ã¾ã™ï¼ˆ<b>é“è·¯ã«ã¯ä¸å¯</b>ï¼‰ã€‚<br/>
          âœ… æ—¢ã«å»ºç‰©ãŒã‚ã‚‹å ´æ‰€ã«ç½®ãã¨ã€ãã®å»ºç‰©ã¯æ¶ˆãˆã€äººå£ãŒæ¸›ã‚Šã¾ã™ï¼ˆä¾‹ï¼šãƒ“ãƒ«ãªã‚‰ -50ï¼‰ã€‚<br/>
          âœ… åŠ¹æœï¼šè­¦å¯Ÿç½²=ç›—é›£/æ”¾ç«ã®æŠ‘æ­¢ã€æ¶ˆé˜²ç½²=æ”¾ç«ã®é®ç«åˆ¤å®šã€ç—…é™¢=æ„ŸæŸ“æ‹¡å¤§ã®æŠ‘æ­¢ã€‚
        </div>
      </div>

      <!-- è£…å‚™/åº— -->
      <div id="tab-shop" class="tab-content space-y-2">
        <div class="text-[10px] border border-white/20 p-2 text-gray-200 bg-black/30">
          ğŸ§° ã‚´ãƒŸè¢‹ç³»ã¯ã€Œè³¼å…¥ â†’ ã‚¿ãƒƒãƒ—ã€ã§è£…å‚™ã§ãã¾ã™ï¼ˆå›åä¸Šé™ãŒå¤‰åŒ–ï¼‰ã€‚<br>
          â€»è£…å‚™/è§£é™¤ã§åŠ¹æœãŒåæ˜ ã•ã‚Œã¾ã™ï¼ˆè³¼å…¥ã—ãŸã ã‘ã§ã¯åæ˜ ã•ã‚Œã¾ã›ã‚“ï¼‰ã€‚
        </div>

        <div class="text-[10px] border border-white/20 p-2 bg-black/30 space-y-2">
          <div class="font-bold text-xs text-center">ğŸ§° è£…å‚™æ¬„</div>
          <div class="grid grid-cols-3 gap-2">
            <div class="border border-white/20 p-2 text-center">
              <div class="text-gray-300">æ­¦å™¨</div>
              <div id="eq-weapon" class="font-bold">-</div>
            </div>
            <div class="border border-white/20 p-2 text-center">
              <div class="text-gray-300">æ‰‹</div>
              <div id="eq-hand" class="font-bold">-</div>
            </div>
            <div class="border border-white/20 p-2 text-center">
              <div class="text-gray-300">èƒ´</div>
              <div id="eq-body" class="font-bold">-</div>
            </div>
          </div>
          <div class="text-[9px] text-gray-300">
            â€»ã€Œè£…å‚™/è§£é™¤ã€ã§åŠ¹æœãŒåæ˜ ã•ã‚Œã¾ã™ï¼ˆè³¼å…¥ã—ãŸã ã‘ã§ã¯åæ˜ ã•ã‚Œã¾ã›ã‚“ï¼‰ã€‚
          </div>
        </div>

        <button onclick="openGachaModal()" class="btn-action w-full flex justify-between items-center">
          <span>ğŸ° ã‚µãƒãƒ¼ãƒˆã‚¬ãƒãƒ£ï¼ˆ1å›ï¼‰</span><span class="text-yellow-400">500G</span>
        </button>
        <button onclick="openSupportModal()" class="btn-action w-full flex justify-between items-center">
          <span>ğŸ§‘â€ğŸ¤â€ğŸ§‘ ã‚µãƒãƒ¼ãƒˆä¸€è¦§ / è£…å‚™</span><span class="text-gray-400">ç®¡ç†</span>
        </button>

        <div id="shop-items" class="space-y-2 pb-4"></div>
      </div>

      <!-- é å¾ -->
      <div id="tab-explore" class="tab-content">
        <div id="ui-town-ctrl" class="space-y-3">
          <div class="flex justify-between text-xs">
            <span>Lv.<span id="ui-lv">1</span> HP:<span id="ui-hp-text">100/100</span></span>
            <span>NEXT:<span id="ui-xp">50</span></span>
          </div>
          <div class="stat-bar"><div id="hp-bar" class="bg-green-500 h-full w-full"></div></div>

          <button onclick="startDungeon()" class="btn-action w-full bg-red-900 py-6 text-lg font-bold">
            â–¶ å»ƒæ£„ç‰©ã‚¨ãƒªã‚¢ã¸é å¾ï¼ˆã‚²ãƒ¼ãƒ é–‹å§‹ï¼‰
          </button>

          <div class="text-[10px] text-gray-300 border border-white/10 p-2">
            â€»é å¾ä¸­ã¯ã€Œè¡—ã¥ãã‚Š/è£…å‚™ã€ã¯é–‹ã‘ã¾ã›ã‚“ã€‚æ’¤é€€ã—ã¦æˆ»ã£ã¦ãã ã•ã„ã€‚
          </div>
        </div>

        <div id="loot-panel" class="mt-3 space-y-1">
          <div class="mt-1 text-[10px] flex justify-between">
            <span>ğŸ—‘ï¸ å›åï¼ˆã‚´ãƒŸè¢‹ï¼‰</span>
            <span><span id="ui-loot">0</span> / <span id="ui-loot-max">100</span></span>
          </div>
          <div class="stat-bar">
            <div id="loot-bar" class="bg-yellow-400 h-full w-0 transition-all duration-300"></div>
          </div>
          <div class="text-[9px] text-gray-300 mt-1">
            è£…å‚™ï¼š<span id="ui-bag-name">-</span>
          </div>
        </div>

        <div id="ui-dungeon-ctrl" class="mt-3 hidden grid grid-cols-2 gap-2">
          <button onclick="dungeonStep()" class="btn-action col-span-2 bg-blue-900 py-8 text-xl">ğŸš¶ æ¢ç´¢(å‰é€²)</button>
          <button onclick="useDrink()" id="btn-drink" class="btn-action">ğŸ§ª ãƒœãƒˆãƒ«(0)</button>
          <button onclick="returnTown()" class="btn-action bg-gray-800">ğŸ  æ’¤é€€</button>
        </div>

        <div id="ui-battle-ctrl" class="mt-3 hidden grid grid-cols-2 gap-2">
          <button id="btn-atk" onclick="battleTurn('attack')" class="btn-action bg-red-600 py-4 font-bold">âš”ï¸ æ”»æ’ƒ</button>
          <button id="btn-def" onclick="battleTurn('defend')" class="btn-action bg-blue-600 py-4 font-bold">ğŸ›¡ï¸ é˜²å¾¡</button>
          <button id="btn-heal" onclick="battleTurn('heal')" class="btn-action bg-green-600 py-4 font-bold">ğŸ§ª å›å¾©</button>
          <button id="btn-flee" onclick="battleTurn('flee')" class="btn-action bg-gray-600 py-4 font-bold">ğŸƒ é€ƒèµ°</button>
        </div>
      </div>
    </div>

    <!-- âœ… ãƒŠãƒ“ï¼ˆsafe-areaå¯¾å¿œã§ã‚¿ãƒ–ãŒæ²ˆã¾ãªã„ï¼‰ -->
    <div class="grid grid-cols-3 bg-white text-black font-bold text-xs shadow-[0_-4px_10px_rgba(0,0,0,0.5)] safe-bottom">
      <button id="nav-town" onclick="showTab('town')" class="py-4 border-r border-gray-300 active:bg-gray-200">è¡—ã¥ãã‚Š</button>
      <button id="nav-shop" onclick="showTab('shop')" class="py-4 border-r border-gray-300 active:bg-gray-200">è£…å‚™/åº—</button>
      <button id="nav-explore" onclick="showTab('explore')" class="py-4 active:bg-gray-200">é å¾</button>
    </div>

    <!-- âœ… åºƒå‘Šæ ã‚‚safe-areaå¯¾å¿œï¼ˆä»»æ„ã ã‘ã©å®‰å®šï¼‰ -->
    <div class="ad-placeholder safe-bottom" onclick="simulateAdReward()">
      ã“ã“ã«ãƒãƒŠãƒ¼åºƒå‘ŠãŒè¡¨ç¤ºã•ã‚Œã¾ã™ (ã‚¯ãƒªãƒƒã‚¯ã§å‹•ç”»åºƒå‘Šå ±é…¬ãƒ†ã‚¹ãƒˆ)
    </div>
  </div>

  <div id="custom-modal">
    <div class="bg-gray-900 border-2 border-white p-6 w-full max-w-xs text-center">
      <div id="modal-text" class="mb-6 text-sm"></div>
      <button onclick="closeModal()" class="btn-action w-full">OK</button>
    </div>
  </div>

  <!-- ã‚¬ãƒãƒ£ãƒ¢ãƒ¼ãƒ€ãƒ« -->
  <div id="gacha-modal" style="display:none; position:absolute; inset:0; background:rgba(0,0,0,0.85); z-index:1200; align-items:center; justify-content:center; padding:18px;">
    <div class="bg-gray-900 border-2 border-white p-4 w-full max-w-sm text-center space-y-3">
      <div class="text-sm font-bold">ğŸ° ã‚µãƒãƒ¼ãƒˆã‚¬ãƒãƒ£</div>
      <div class="text-[10px] text-gray-300">500Gã§1å›ã€‚ã‚µãƒãƒ¼ãƒˆãŒå¢—ãˆã‚‹ã»ã©ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãŒä¼¸ã³ã¾ã™ã€‚</div>
      <div id="gacha-result" class="text-sm py-3 border border-white/20 bg-black/40">çµæœã¯ã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™</div>
      <div class="grid grid-cols-2 gap-2">
        <button onclick="doGachaOnce()" class="btn-action">1å›å¼•ã</button>
        <button onclick="closeGachaModal()" class="btn-action">é–‰ã˜ã‚‹</button>
      </div>
    </div>
  </div>

  <!-- ã‚µãƒãƒ¼ãƒˆç®¡ç†ãƒ¢ãƒ¼ãƒ€ãƒ« -->
  <div id="support-modal" style="display:none; position:absolute; inset:0; background:rgba(0,0,0,0.85); z-index:1200; align-items:center; justify-content:center; padding:18px;">
    <div class="bg-gray-900 border-2 border-white p-4 w-full max-w-sm text-left space-y-3">
      <div class="text-center text-sm font-bold">ğŸ§‘â€ğŸ¤â€ğŸ§‘ ã‚µãƒãƒ¼ãƒˆç®¡ç†</div>
      <div class="text-[10px] text-gray-300">æ‰€æŒä¸€è¦§ã‹ã‚‰ã‚¹ãƒ­ãƒƒãƒˆ1ã€œ3ã«è£…å‚™ã§ãã¾ã™ã€‚</div>

      <div class="text-[10px] border border-white/20 p-2 bg-black/30">
        è£…å‚™ä¸­ï¼šâ‘  <span id="eq1">-</span> ï¼ â‘¡ <span id="eq2">-</span> ï¼ â‘¢ <span id="eq3">-</span>
      </div>

      <div id="support-list" class="space-y-2 max-h-[45vh] overflow-y-auto"></div>

      <button onclick="closeSupportModal()" class="btn-action w-full">é–‰ã˜ã‚‹</button>
    </div>
  </div>

<script>
  /* =========================================================
     âœ… iPhone Safariã®100vhã‚ºãƒ¬å¯¾ç­–ï¼šå®Ÿæ¸¬ã®é«˜ã•ã‚’CSSå¤‰æ•°ã¸
     ========================================================= */
  function setAppHeightVar() {
    document.documentElement.style.setProperty('--app-h', `${window.innerHeight}px`);
  }
  window.addEventListener('resize', setAppHeightVar);
  window.addEventListener('orientationchange', setAppHeightVar);
  setAppHeightVar();

  // =========================================================
  // 4ã‚¹ãƒ†å¯¾å¿œï¼ˆATK/DEF/SPD/LUKï¼‰
  // =========================================================

  const MONEY_PER_LOOT = 5;
  const CITY_WASTE_REDUCTION_PER_LOOT = 0.03;

  const ENEMY_WASTE_SCALE_MAX = 15;
  const ENEMY_HP_BOOST_MAX = 1.2;
  const ENEMY_ATK_BOOST_MAX = 0.6;

  const BOSS_DISTANCE_M = 200;
  const STEP_M = 10;
  const BOSS_DISTANCE_STEP = Math.floor(BOSS_DISTANCE_M / STEP_M);
  const BOSS_WASTE_REDUCE_RATE = 0.30;

  const BOSS = {
    n: "ä¸æ³•æŠ•æ£„ã‚­ãƒ³ã‚°",
    h: 900,
    a: 65,
    s: 12,
    x: 900,
    e: "ğŸ‘‘",
    imgKey: null,
    hpWeight: 0.8,
    atkWeight: 0.7
  };

  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const floor1 = (v)=>Math.max(1, Math.floor(v));

  function critChance(luk){ return clamp(luk * 0.005, 0, 0.25); }
  function dodgeChance(spd, enemySpd){ return clamp((spd - enemySpd) * 0.03, 0, 0.25); }
  function reduceDamage(raw, def){
    return floor1(raw * 100 / (100 + Math.max(0, def)));
  }

  const canvas = document.getElementById('game-canvas');
  const ctx = canvas.getContext('2d');

  function resizeCanvas() {
    const container = document.getElementById('screen-container');
    canvas.width = container.clientWidth;
    canvas.height = 200;
  }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  const assetStatusEl = document.getElementById('asset-status');

  function loadImage(src) {
    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => resolve({ ok: true, img, src });
      img.onerror = () => resolve({ ok: false, img: null, src });
      img.src = src;
    });
  }

  const ASSET_PATH = "assets/";

  const ASSET_LIST = {
    sy:     ASSET_PATH + "support/yuzuki/yuzuki.png",
    sm:     ASSET_PATH + "support/mirako/mirako.png",
    sf:     ASSET_PATH + "support/fromzero/fromzero.png",

    road:   ASSET_PATH + "road_tiles.png",
    build:  ASSET_PATH + "building_tiles.png",
    civic:  ASSET_PATH + "service_buildings.png",
    player: ASSET_PATH + "player_sheet.jpg",
    e1:     ASSET_PATH + "enemy_1_cutout.png",
    e2:     ASSET_PATH + "enemy_2_cutout.png",
    e3:     ASSET_PATH + "enemy_3_cutout.png",
  };

  const ASSETS = {
    supportY:{ img: null, ok: false },
    supportM:{ img: null, ok: false },
    supportF:{ img: null, ok: false },
    road:  { img: null, ok: false },
    build: { img: null, ok: false },
    civic: { img: null, ok: false },
    player:{ img: null, ok: false },
    enemy1:{ img: null, ok: false },
    enemy2:{ img: null, ok: false },
    enemy3:{ img: null, ok: false },
  };

  const ROAD_TILES  = { get img(){ return ASSETS.road.img;  }, get ready(){ return ASSETS.road.ok;  }, tileSize: 128, cols: 8 };
  const BUILD_TILES = { get img(){ return ASSETS.build.img; }, get ready(){ return ASSETS.build.ok; }, tileSize: 256, cols: 6 };
  const CIVIC_TILES = { get img(){ return ASSETS.civic.img; }, get ready(){ return ASSETS.civic.ok; }, tileSize: 0, cols: 3 };

  async function loadAllAssets() {
    const keys = Object.keys(ASSET_LIST);
    const results = await Promise.all(keys.map(k => loadImage(ASSET_LIST[k])));
    const bySrc = new Map(results.map(r => [r.src, r]));

    function put(targetKey, src) {
      const r = bySrc.get(src);
      ASSETS[targetKey].ok = !!r?.ok;
      ASSETS[targetKey].img = r?.img || null;
    }

    put("supportY", ASSET_LIST.sy);
    put("supportM", ASSET_LIST.sm);
    put("supportF", ASSET_LIST.sf);
    put("road",  ASSET_LIST.road);
    put("build", ASSET_LIST.build);
    put("civic", ASSET_LIST.civic);
    put("player",ASSET_LIST.player);
    put("enemy1",ASSET_LIST.e1);
    put("enemy2",ASSET_LIST.e2);
    put("enemy3",ASSET_LIST.e3);

    if (ASSETS.civic.ok && ASSETS.civic.img) {
      CIVIC_TILES.cols = 3;
      CIVIC_TILES.tileSize = Math.floor(ASSETS.civic.img.width / 3);
      if (!CIVIC_TILES.tileSize || CIVIC_TILES.tileSize < 1) CIVIC_TILES.tileSize = 64;
    }

    updateAssetStatus();
  }

  function updateAssetStatus() {
    const s = (ok)=> ok ? "OK" : "NG";
    assetStatusEl.innerText =
      `ASSET\n`+
      `road:${s(ASSETS.road.ok)} build:${s(ASSETS.build.ok)} civic:${s(ASSETS.civic.ok)}\n`+
      `ply:${s(ASSETS.player.ok)} e1:${s(ASSETS.enemy1.ok)} e2:${s(ASSETS.enemy2.ok)} e3:${s(ASSETS.enemy3.ok)}`;
  }

  const ENEMY_IMG = {
    enemy1: { get img(){ return ASSETS.enemy1.img; }, get ready(){ return ASSETS.enemy1.ok; } },
    enemy2: { get img(){ return ASSETS.enemy2.img; }, get ready(){ return ASSETS.enemy2.ok; } },
    enemy3: { get img(){ return ASSETS.enemy3.img; }, get ready(){ return ASSETS.enemy3.ok; } },
  };

  function drawEnemySprite(enemy, x, y) {
    if (!enemy) return;

    const key = enemy.imgKey;
    const pack = key ? ENEMY_IMG[key] : null;

    if (pack && pack.ready && pack.img) {
      const img = pack.img;
      const targetW = Math.floor(canvas.width * 0.34);
      const scale = targetW / img.width;
      const dw = Math.floor(img.width * scale);
      const dh = Math.floor(img.height * scale);

      ctx.save();
      ctx.imageSmoothingEnabled = true;
      ctx.drawImage(img, x - dw/2, y - dh/2, dw, dh);
      ctx.restore();
      return;
    }

    ctx.save();
    ctx.font = "48px 'DotGothic16', monospace";
    ctx.textAlign = "center";
    ctx.fillText(enemy.e || "ğŸ‘¾", x, y);
    ctx.restore();
  }

  function drawTileSheet(tilePack, tileId, dx, dy, dw, dh, fallbackColor) {
    if (!tilePack.ready || !tilePack.img || !tilePack.tileSize) {
      ctx.fillStyle = fallbackColor || "#333";
      ctx.fillRect(dx, dy, dw, dh);
      ctx.save();
      ctx.globalAlpha = 0.9;
      ctx.fillStyle = "#ff4444";
      ctx.font = "10px 'DotGothic16'";
      ctx.textAlign = "left";
      ctx.textBaseline = "top";
      ctx.fillText("IMG?", dx + 2, dy + 2);
      ctx.restore();
      return;
    }
    const ts = tilePack.tileSize;
    const sx = (tileId % tilePack.cols) * ts;
    const sy = Math.floor(tileId / tilePack.cols) * ts;
    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(tilePack.img, sx, sy, ts, ts, dx, dy, dw, dh);
  }

  const TILE_GRASS = 0;
  const TILE_ROAD  = 1;

  const BLD_EMPTY = -1;
  const BLD_HUT   = 0;
  const BLD_HOUSE = 1;
  const BLD_APT   = 2;
  const BLD_BIG   = 3;
  const BLD_PARK  = 10;
  const BLD_TREE  = 16;

  const BLD_POLICE   = 100;
  const BLD_FIRE     = 101;
  const BLD_HOSPITAL = 102;

  function isFacilityTile(id) {
    return id === BLD_POLICE || id === BLD_FIRE || id === BLD_HOSPITAL;
  }
  function civicTileIdOfBuildingId(id) {
    if (id === BLD_POLICE) return 0;
    if (id === BLD_FIRE) return 1;
    if (id === BLD_HOSPITAL) return 2;
    return -1;
  }

  const TOWN_W = 16;
  const TOWN_H = 9;

  let townMap = Array.from({ length: TOWN_H }, (_, y) =>
    Array.from({ length: TOWN_W }, (_, x) =>
      (y === Math.floor(TOWN_H / 2) ? TILE_ROAD : TILE_GRASS)
    )
  );

  let buildingMap = Array.from({ length: TOWN_H }, () =>
    Array.from({ length: TOWN_W }, () => BLD_EMPTY)
  );

  let infected = Array.from({ length: TOWN_H }, () =>
    Array.from({ length: TOWN_W }, () => 0)
  );

  const RARITY_MULT = { 1: 0.6, 2: 0.8, 3: 1.0, 4: 1.25, 5: 1.55 };

  const SUPPORT_MASTER = {
    yuzuki: {
      name: "ã‚†ã¥ã",
      icon: "âœ¨",
      imgKey: "supportY",
      base: { atk: 15, def: 0, spd: 1, maxHp: 0 },
      skill: { id: "focus_clean", name: "é›†ä¸­æ¸…æƒ" }
    },
    mirako: {
      name: "ã¿ã‚‰ã“",
      icon: "ğŸŒ¸",
      imgKey: "supportM",
      base: { atk: 2, def: 3, spd: 2, maxHp: 20 },
      skill: { id: "env_barrier", name: "ç’°å¢ƒãƒãƒªã‚¢" }
    },
    fromzero: {
      name: "FromZero",
      icon: "ğŸ§¹",
      imgKey: "supportF",
      base: { atk: 4, def: 1, spd: 0, maxHp: 30 },
      skill: { id: "zero_restart", name: "ã‚¼ãƒ­ã‹ã‚‰ã®ã‚¹ã‚¿ãƒ¼ãƒˆ" }
    }
  };

  const DUPE_RATE = { 1: 0.01, 2: 0.02, 3: 0.04, 4: 0.07, 5: 0.10 };

  function rarityColor(r) {
    if (r === 1) return "#ffffff";
    if (r === 2) return "#22c55e";
    if (r === 3) return "#3b82f6";
    if (r === 4) return "#a855f7";
    if (r === 5) return "#ef4444";
    return "#ffffff";
  }
  function rarityText(r, dupes = 0) {
    const stars = "â˜…".repeat(r);
    return dupes > 0 ? `${stars}+${dupes}` : stars;
  }
  function rarityBadgeHTML(r, dupes = 0) {
    const color = rarityColor(r);
    const txt = rarityText(r, dupes);
    return `<span style="color:${color}; font-weight:bold;">${txt}</span>`;
  }
  function getSupportSkillDisplayName(unit) {
    if (!unit) return "-";
    const m = SUPPORT_MASTER[unit.masterId];
    if (!m) return "-";
    if (unit.masterId === "yuzuki" && (unit.rarity ?? 1) >= 4) return `${m.skill.name}(æ”¹)`;
    return m.skill.name;
  }

  let state = {
    mode: 'town',     // town / dungeon / battle
    uiTab: 'town',    // town / shop / explore

    money: 500,
    population: 100,
    staff: 0,
    staffCost: 300,
    stats: { env: 80, security: 80, health: 80 },
    wasteRate: 0,
    inventory: [],
    player: {
      lv: 1, xp: 0, next: 50,
      hp: 100, maxHp: 100,
      baseAtk: 12,
      baseDef: 0,
      baseSpd: 5,
      baseLuk: 5,
      drinks: 1,
      bagId: 'bag_s',
      equip: { weapon: null, hand: null, body: null },
    },
    loot: { cur: 0, max: 100 },
    distance: 0,
    enemy: null,
    battle: { isPlayerTurn: false, isAnimating: false, defending: false },
    lastTick: Date.now(),
    lastDisasterAt: 0,
    placing: { active: false, type: null },
    patrol: { until: 0 },
    dungeon: { bossSpawned: false, bossDefeated: false, zeroUsed: false },

    // âœ… ä¸–ç•Œå´©å£Šãƒ•ã‚§ãƒ¼ã‚º state
    collapse: {
  active: false,
  enteredOnce: false,
  overlayUntil: 0,
  driftEventFired: false,
  tutorialBossDefeated: false,
  cooldownUntil: 0,

  // âœ… è¿½åŠ ï¼ˆæ–°è§£é™¤æ¡ä»¶ç”¨ï¼‰
  recoverHoldMs: 0,
  recoverLastAt: 0
},
    supports: {
      inventory: [],
      slots: { slot1: null, slot2: null, slot3: null }
    },

    _supportMigrated_v2: false
  };

  const DISASTER_COOLDOWN_MS = 30_000;
  const ARSON_POP_LOSS_RATE = 0.03;
  const THEFT_MONEY_LOSS_RATE = 0.03;
  const DISEASE_POP_LOSS_RATE = 0.02;

  const FACILITY_COST  = { hospital: 2500, police: 6000, fire: 6000 };
  const FACILITY_LIMIT = { hospital: 5, police: 99, fire: 99 };

  const POP_LOSS_BY_BUILDING = { hut: 10, house: 20, apt: 35, big: 50, park: 0, tree: 0 };

  // =========================
  // ãƒ‘ãƒˆãƒ­ãƒ¼ãƒ«ï¼ˆæ²»å®‰ãƒ–ãƒ¼ã‚¹ãƒˆï¼‰
  // =========================
  const PATROL_COST = 400;
  const PATROL_DURATION_MS = 60_000; // 60ç§’
  const PATROL_SECURITY_GAIN = 10;   // å³æ™‚æ²»å®‰+10
  const PATROL_REGEN_BONUS = 0.8;    // æ¯ç§’ã®æ²»å®‰å›å¾©+0.8ï¼ˆãƒ‘ãƒˆãƒ­ãƒ¼ãƒ«ä¸­ï¼‰
  const PATROL_CRIME_REDUCE_BONUS = 0.20;

  function isPatrolActive() {
    return (state.patrol?.until ?? 0) > Date.now();
  }

  function startPatrol() {
    if (isPatrolActive()) {
      const left = Math.ceil((state.patrol.until - Date.now()) / 1000);
      logMessage(`ğŸš¶ ãƒ‘ãƒˆãƒ­ãƒ¼ãƒ«ä¸­ã§ã™ï¼ˆæ®‹ã‚Š ${left}sï¼‰`);
      updateUI();
      return;
    }

    if (state.mode !== 'town' || state.uiTab !== 'town') {
      logMessage("è¡—ã«ã„ã‚‹æ™‚ã ã‘ãƒ‘ãƒˆãƒ­ãƒ¼ãƒ«ã§ãã¾ã™ã€‚");
      return;
    }

    if (state.money < PATROL_COST) {
      openModal("è³‡é‡‘ãŒè¶³ã‚Šã¾ã›ã‚“ã€‚");
      return;
    }

    state.money -= PATROL_COST;
    state.patrol.until = Date.now() + PATROL_DURATION_MS;

    state.stats.security = clamp(state.stats.security + PATROL_SECURITY_GAIN, 0, 100);

    logMessage(`ğŸš¶ ãƒ‘ãƒˆãƒ­ãƒ¼ãƒ«é–‹å§‹ï¼æ²»å®‰ +${PATROL_SECURITY_GAIN}ï¼ˆ60ç§’é–“ãƒ–ãƒ¼ã‚¹ãƒˆï¼‰`);
    updateUI();
    saveGame();
  }
// âœ… å´©å£Šè§£é™¤æ¡ä»¶ï¼ˆæ–°ï¼‰
// ã‚´ãƒŸ1å„„ä»¥ä¸‹ ï¼‹ ç’°å¢ƒ/æ²»å®‰/å¥åº·30%ä»¥ä¸Š ã‚’ä¸€å®šæ™‚é–“ä¿æŒ
const RECOVER_THRESHOLD = 30;
const RECOVER_WASTE_MAX = 100_000_000;
const RECOVER_HOLD_MS   = 30_000; // 30ç§’ï¼ˆå¥½ã¿ã§å¤‰æ›´OKï¼‰
  // =========================================================
  // âœ… ä¸–ç•Œå´©å£Šãƒ•ã‚§ãƒ¼ã‚ºï¼ˆå®Ÿè£…ï¼‰
  // =========================================================
  function ensureCollapseState() {
  if (!state.collapse) {
    state.collapse = {
      active: false,
      enteredOnce: false,
      overlayUntil: 0,
      driftEventFired: false,
      tutorialBossDefeated: false,
      cooldownUntil: 0,
      recoverHoldMs: 0,
      recoverLastAt: 0
    };
    return;
  }

  // æ—¢å­˜ã‚»ãƒ¼ãƒ–äº’æ›ï¼ˆå¤ã„ã‚»ãƒ¼ãƒ–ã«é …ç›®ãŒç„¡ã„å ´åˆï¼‰
  if (state.collapse.active == null) state.collapse.active = false;
  if (state.collapse.enteredOnce == null) state.collapse.enteredOnce = false;
  if (state.collapse.overlayUntil == null) state.collapse.overlayUntil = 0;
  if (state.collapse.driftEventFired == null) state.collapse.driftEventFired = false;
  if (state.collapse.tutorialBossDefeated == null) state.collapse.tutorialBossDefeated = false;
  if (state.collapse.cooldownUntil == null) state.collapse.cooldownUntil = 0;

  // è§£é™¤æ¡ä»¶ã®ä¿æŒã‚¿ã‚¤ãƒãƒ¼ï¼ˆä»Šå›è¿½åŠ åˆ†ï¼‰
  if (state.collapse.recoverHoldMs == null) state.collapse.recoverHoldMs = 0;
  if (state.collapse.recoverLastAt == null) state.collapse.recoverLastAt = 0;
}

  function showCollapseOverlay(ms = 2000) {
    const el = document.getElementById("collapse-overlay");
    if (!el) return;
    el.style.display = "flex";
    state.collapse.overlayUntil = Date.now() + ms;
  }

  function tickCollapseOverlay() {
    const el = document.getElementById("collapse-overlay");
    if (!el) return;
    if (!state.collapse?.active) { el.style.display = "none"; return; }

    if (Date.now() > (state.collapse.overlayUntil || 0)) {
      el.style.display = "none";
    } else {
      el.style.display = "flex";
    }
  }

  function enterCollapsePhase(reasonText = "è‡¨ç•Œåˆ°é”") {
    ensureCollapseState();
    if (state.collapse.active) return;

    state.collapse.active = true;
    state.collapse.enteredOnce = true;

    const t = document.getElementById("collapse-text");
    if (t) {
      t.innerHTML =
        `å´©å£ŠãŒå§‹ã¾ã‚Šã¾ã—ãŸã€‚<br>` +
        `ç’°å¢ƒãƒ»æ²»å®‰ãƒ»å¥åº·ãŒæ€¥æ¿€ã«æ‚ªåŒ–ã—ã¾ã™ã€‚<br>` +
        `<span style="color:#f87171;">åŸå› ï¼š</span>${reasonText}`;
    }
    showCollapseOverlay(2200);

    logMessage("âš  ä¸–ç•Œå´©å£Šãƒ•ã‚§ãƒ¼ã‚ºã«çªå…¥â€¦ï¼");
    updateUI();
    saveGame();
  }

  // è§£é™¤æ¡ä»¶ï¼ˆä¾‹ï¼‰ï¼šç’°å¢ƒ/æ²»å®‰/å¥åº·ãŒå…¨ã¦80%ä»¥ä¸Š
  function tryExitCollapsePhase() {
  ensureCollapseState();
  if (!state.collapse.active) return;

  const now = Date.now();

  // âœ… å¾©èˆˆè§£é™¤ï¼ˆå¾“æ¥ï¼‰ï¼šenv/sec/heal å…¨ã¦80%ä»¥ä¸Š
  const recovered =
    (state.stats.env >= 80) &&
    (state.stats.security >= 80) &&
    (state.stats.health >= 80);

  // âœ… å£Šæ»…è§£é™¤ï¼ˆæ•‘æ¸ˆï¼‰ï¼šäººå£10ä»¥ä¸‹ & ã‚´ãƒŸ0.5ä»¥ä¸‹
  const devastated =
    (state.population <= 10) &&
    ((state.wasteRate ?? 0) <= 0.5);

  // âœ… æ•‘æ¸ˆè§£é™¤ï¼ˆæ–°ï¼‰ï¼šã‚´ãƒŸ1å„„ä»¥ä¸‹ ï¼‹ env/sec/healãŒ30%ä»¥ä¸Šã‚’ä¸€å®šæ™‚é–“ç¶­æŒ
  const okStats =
    (state.stats.env >= RECOVER_THRESHOLD) &&
    (state.stats.security >= RECOVER_THRESHOLD) &&
    (state.stats.health >= RECOVER_THRESHOLD);

  const okWaste = (state.wasteRate ?? 0) <= RECOVER_WASTE_MAX;

  let recoveredByHold = false;

  if (okStats && okWaste) {
    if (!state.collapse.recoverLastAt) state.collapse.recoverLastAt = now;
    const dt = now - state.collapse.recoverLastAt;

    state.collapse.recoverHoldMs = (state.collapse.recoverHoldMs ?? 0) + dt;
    state.collapse.recoverLastAt = now;

    if (state.collapse.recoverHoldMs >= RECOVER_HOLD_MS) {
      recoveredByHold = true;
    }
  } else {
    // æ¡ä»¶ãŒå´©ã‚ŒãŸã‚‰ãƒªã‚»ãƒƒãƒˆ
    state.collapse.recoverHoldMs = 0;
    state.collapse.recoverLastAt = now;
  }

  // âœ… è§£é™¤åˆ¤å®š
  if (!(recovered || recoveredByHold || devastated)) return;

  // âœ… è§£é™¤å‡¦ç†
  state.collapse.active = false;

  // âœ… è§£é™¤ç›´å¾Œã®å³å†çªå…¥ã‚’é˜²ãï¼ˆ5ç§’ï¼‰
  state.collapse.cooldownUntil = now + 5000;

  if (devastated) {
    // å£Šæ»…è§£é™¤ï¼šå³å†çªå…¥ã‚’é¿ã‘ã‚‹æœ€ä½é™ã®åº•ä¸Šã’
    state.stats.env = Math.max(state.stats.env, 5);
    state.stats.security = Math.max(state.stats.security, 5);
    state.stats.health = Math.max(state.stats.health, 5);
    logMessage("ğŸ•¯ï¸ å´©å£Šã¯çµ‚ã‚ã£ãŸâ€¦ï¼ˆå£Šæ»…ï¼‰ã€‚ã“ã“ã‹ã‚‰â€œã‚¼ãƒ­ã‹ã‚‰ã®å†å»ºâ€ãŒå§‹ã¾ã‚‹ã€‚");
  } else if (recoveredByHold) {
    logMessage("ğŸŒ± ãªã‚“ã¨ã‹è¸ã¿ã¨ã©ã¾ã£ãŸâ€¦ï¼ˆæ•‘æ¸ˆè§£é™¤ï¼‰ã€‚è¡—ã¯å†å»ºã¸å‘ã‹ã†ï¼");
  } else {
    logMessage("âœ¨ å´©å£Šã‚’é£Ÿã„æ­¢ã‚ãŸâ€¦è¡—ã¯æŒã¡ç›´ã—ãŸï¼");
  }

  const el = document.getElementById("collapse-overlay");
  if (el) el.style.display = "none";

  updateUI();
  saveGame();
}  // å´©å£Šä¸­ã®æ¯ç§’å‡¦ç†ï¼ˆå¼·åˆ¶çš„ã«æ‚ªåŒ–ï¼‰
  function applyCollapseTick() {
    ensureCollapseState();
    if (!state.collapse.active) return;

    state.stats.env      = clamp(state.stats.env      - 1.2, 0, 100);
    state.stats.security = clamp(state.stats.security - 1.0, 0, 100);
    state.stats.health   = clamp(state.stats.health   - 1.0, 0, 100);

    state.wasteRate += 2.0;
    state.population = Math.max(10, Math.floor(state.population * 0.99));

    tickCollapseOverlay();
    tryExitCollapsePhase();
  }

  function checkCollapseTriggers() {
    ensureCollapseState();
    if (state.collapse.active) return;

  // âœ… è¿½åŠ ï¼šè§£é™¤ç›´å¾Œã¯å†çªå…¥ã—ãªã„
  if (Date.now() < (state.collapse.cooldownUntil || 0)) return;

    // åˆå›ï¼šèµ¤å¡šå…¬åœ’ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ãƒœã‚¹æ’ƒç ´å¾Œã«å¼·åˆ¶çªå…¥
    if (!state.collapse.enteredOnce && state.collapse.tutorialBossDefeated) {
      enterCollapsePhase("èµ¤å¡šå…¬åœ’ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ï¼šãƒœã‚¹æ’ƒç ´å¾Œã®å´©å£Šçªå…¥");
      return;
    }

    // 2å›ç›®ä»¥é™ï¼štrash overflow
    if ((state.wasteRate ?? 0) >= 1_000_000_000) {
      enterCollapsePhase("OVERFLOWï¼šã‚´ãƒŸãŒè‡¨ç•Œï¼ˆ1,000,000,000ï¼‰ã‚’çªç ´");
      return;
    }

    // env/sec/heal ã®ã†ã¡2ã¤ä»¥ä¸ŠãŒ0
    const zeros =
      (state.stats.env <= 0 ? 1 : 0) +
      (state.stats.security <= 0 ? 1 : 0) +
      (state.stats.health <= 0 ? 1 : 0);
    if (zeros >= 2) {
      enterCollapsePhase("è‡¨ç•Œï¼šç’°å¢ƒ/æ²»å®‰/å¥åº·ã®ã†ã¡2ã¤ãŒ0%");
      return;
    }

    // è’å·ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³ã€Œå¤§é‡æ¼‚ç€ãƒã‚¤ãƒ³ãƒˆã€ã‚¤ãƒ™ãƒ³ãƒˆç™ºç”Ÿï¼ˆå°†æ¥ç”¨ï¼‰
    if (state.collapse.driftEventFired) {
      enterCollapsePhase("è’å·ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³ï¼šå¤§é‡æ¼‚ç€ãƒã‚¤ãƒ³ãƒˆç™ºç”Ÿ");
      state.collapse.driftEventFired = false; // é€£ç¶šç™ºç«é˜²æ­¢
      return;
    }
  }

  function ensureSupportState() {
    if (!state.supports) state.supports = { inventory: [], slots: { slot1: null, slot2: null, slot3: null } };
    if (!state.supports.inventory) state.supports.inventory = [];
    if (!state.supports.slots) state.supports.slots = { slot1: null, slot2: null, slot3: null };
  }

  function migrateSupportsIfNeeded() {
    if (!state._supportMigrated_v2) {
      state.supports = { inventory: [], slots: { slot1: null, slot2: null, slot3: null } };
      state._supportMigrated_v2 = true;
    }
  }

  function getSupportUnit(uid) {
    ensureSupportState();
    return state.supports.inventory.find(u => u.uid === uid) || null;
  }

  function getEquippedSupports() {
    ensureSupportState();
    const ids = Object.values(state.supports.slots).filter(Boolean);
    return ids.map(getSupportUnit).filter(Boolean);
  }

  function calcSupportBonus() {
    ensureSupportState();
    const units = getEquippedSupports();
    let b = { atk: 0, def: 0, spd: 0, maxHp: 0 };

    for (const u of units) {
      const m = SUPPORT_MASTER[u.masterId];
      if (!m) continue;

      const rarity = u.rarity ?? 1;
      const rMul = RARITY_MULT[rarity] ?? 1.0;

      const level = u.level ?? 1;
      const lvMul = 1 + Math.max(0, level - 1) * 0.06;

      const dupes = u.dupes ?? 0;
      const rate = DUPE_RATE[rarity] ?? 0;
      const dupeMul = 1 + (dupes * rate);

      const mul = rMul * lvMul * dupeMul;

      b.atk   += Math.floor((m.base.atk   ?? 0) * mul);
      b.def   += Math.floor((m.base.def   ?? 0) * mul);
      b.spd   += Math.floor((m.base.spd   ?? 0) * mul);
      b.maxHp += Math.floor((m.base.maxHp ?? 0) * mul);
    }
    return b;
  }

  function countFacility(type) {
    const id = type === 'hospital' ? BLD_HOSPITAL : type === 'police' ? BLD_POLICE : BLD_FIRE;
    let c = 0;
    for (let y = 0; y < TOWN_H; y++) for (let x = 0; x < TOWN_W; x++) {
      if (buildingMap[y][x] === id) c++;
    }
    return c;
  }

  function getFacilityEffects() {
    const p = countFacility('police');
    const f = countFacility('fire');
    const h = countFacility('hospital');

    const securityRegen = Math.min(1.2, 0.15 * p);
    const crimeReduce   = Math.min(0.75, 0.18 * p);
    const fireSuccessChance = Math.min(0.90, 0.25 + 0.18 * f);
    const healthRegen = Math.min(1.0, 0.18 * h);
    const diseaseReduce = Math.min(0.70, 0.15 * h);

    return { securityRegen, crimeReduce, fireSuccessChance, healthRegen, diseaseReduce };
  }

  function selectFacilityToPlace(type) {
    const limit = FACILITY_LIMIT[type] ?? 99;
    if (countFacility(type) >= limit) {
      openModal(`${type === 'hospital' ? 'ç—…é™¢' : type === 'police' ? 'è­¦å¯Ÿç½²' : 'æ¶ˆé˜²ç½²'}ã¯ä¸Šé™ï¼ˆ${limit}ï¼‰ã«é”ã—ã¦ã„ã¾ã™ã€‚`);
      return;
    }
    const cost = FACILITY_COST[type] ?? 0;
    if (state.money < cost) {
      openModal("è³‡é‡‘ãŒè¶³ã‚Šã¾ã›ã‚“ã€‚");
      return;
    }

    state.placing.active = true;
    state.placing.type = type;
    document.getElementById('place-hint').classList.remove('hidden');
    logMessage(`è¨­ç½®ãƒ¢ãƒ¼ãƒ‰ï¼š${type === 'hospital' ? 'ğŸ¥ç—…é™¢' : type === 'police' ? 'ğŸš“è­¦å¯Ÿç½²' : 'ğŸš’æ¶ˆé˜²ç½²'}ã€‚ç½®ãå ´æ‰€ã‚’ã‚¿ãƒƒãƒ—ã—ã¦ãã ã•ã„ã€‚`);
  }

  function cancelPlacing() {
    state.placing.active = false;
    state.placing.type = null;
    document.getElementById('place-hint').classList.add('hidden');
  }

  function isRoad(x, y) { return townMap?.[y]?.[x] === TILE_ROAD; }

  function popLossByExistingBuildingId(id) {
    if (id === BLD_HUT) return POP_LOSS_BY_BUILDING.hut;
    if (id === BLD_HOUSE) return POP_LOSS_BY_BUILDING.house;
    if (id === BLD_APT) return POP_LOSS_BY_BUILDING.apt;
    if (id === BLD_BIG) return POP_LOSS_BY_BUILDING.big;
    if (id === BLD_PARK) return POP_LOSS_BY_BUILDING.park;
    if (id === BLD_TREE) return POP_LOSS_BY_BUILDING.tree;
    return 0;
  }

  function placeFacilityAt(x, y) {
    if (!state.placing.active) return;
    if (x < 0 || x >= TOWN_W || y < 0 || y >= TOWN_H) return;

    if (isRoad(x, y)) {
      logMessage("é“è·¯ã«ã¯ç½®ã‘ã¾ã›ã‚“ã€‚åˆ¥ã®ãƒã‚¹ã‚’ã‚¿ãƒƒãƒ—ã—ã¦ãã ã•ã„ã€‚");
      return;
    }

    const type = state.placing.type;
    const cost = FACILITY_COST[type] ?? 0;

    const limit = FACILITY_LIMIT[type] ?? 99;
    if (countFacility(type) >= limit) { openModal("ä¸Šé™ã«é”ã—ã¦ã„ã¾ã™ã€‚"); cancelPlacing(); return; }
    if (state.money < cost) { openModal("è³‡é‡‘ãŒè¶³ã‚Šã¾ã›ã‚“ã€‚"); cancelPlacing(); return; }

    const existing = buildingMap[y][x];
    if (existing !== BLD_EMPTY && !isFacilityTile(existing)) {
      const loss = popLossByExistingBuildingId(existing);
      state.population = Math.max(10, state.population - loss);
      logMessage(`å»ºã¦æ›¿ãˆï¼šæ—¢å­˜å»ºç‰©ãŒæ¶ˆå¤±â€¦ äººå£ -${loss}`);
    }

    const id = type === 'hospital' ? BLD_HOSPITAL : type === 'police' ? BLD_POLICE : BLD_FIRE;
    state.money -= cost;
    buildingMap[y][x] = id;

    logMessage(`${type === 'hospital' ? 'ğŸ¥ ç—…é™¢' : type === 'police' ? 'ğŸš“ è­¦å¯Ÿç½²' : 'ğŸš’ æ¶ˆé˜²ç½²'}ã‚’è¨­ç½®ã—ã¾ã—ãŸï¼`);
    cancelPlacing();
    updateUI();
  }

  canvas.addEventListener('pointerdown', (ev) => {
    if (state.uiTab !== 'town') return;
    if (state.mode !== 'town') return;
    if (!state.placing.active) return;

    const rect = canvas.getBoundingClientRect();
    const cx = ev.clientX - rect.left;
    const cy = ev.clientY - rect.top;

    const geo = getTownDrawGeo();
    if (!geo) return;
    const { ox, oy, tileDrawSize, mapWpx, mapHpx } = geo;

    if (cx < ox || cy < oy || cx >= ox + mapWpx || cy >= oy + mapHpx) return;

    const x = Math.floor((cx - ox) / tileDrawSize);
    const y = Math.floor((cy - oy) / tileDrawSize);

    placeFacilityAt(x, y);
  });

  const PLAYER_SPR = {
    get img(){ return ASSETS.player.img; },
    get ready(){ return ASSETS.player.ok; },
    cols: 5,
    frameW: 0,
    frameH: 0,
    scale: 2.8,
    flipX: true
  };

  function setupPlayerSpriteMeta() {
    if (!PLAYER_SPR.ready || !PLAYER_SPR.img) return;
    PLAYER_SPR.frameW = Math.floor(PLAYER_SPR.img.width / PLAYER_SPR.cols);
    PLAYER_SPR.frameH = PLAYER_SPR.img.height;
  }

  function drawPlayerFrame(frameIndex, x, y) {
    if (!PLAYER_SPR.ready || !PLAYER_SPR.img || !PLAYER_SPR.frameW || !PLAYER_SPR.frameH) return;
    const fw = PLAYER_SPR.frameW;
    const fh = PLAYER_SPR.frameH;
    const sx = frameIndex * fw;
    const sy = 0;
    const dw = fw * PLAYER_SPR.scale;
    const dh = fh * PLAYER_SPR.scale;

    ctx.save();
    ctx.imageSmoothingEnabled = false;
    if (PLAYER_SPR.flipX) {
      ctx.translate(x + dw, y);
      ctx.scale(-1, 1);
      ctx.drawImage(PLAYER_SPR.img, sx, sy, fw, fh, 0, 0, dw, dh);
    } else {
      ctx.drawImage(PLAYER_SPR.img, sx, sy, fw, fh, x, y, dw, dh);
    }
    ctx.restore();
  }

  const playerAnim = { walkUntil: 0, attackUntil: 0 };
  function playWalk(ms = 450)   { playerAnim.walkUntil = Date.now() + ms; }
  function playAttack(ms = 260) { playerAnim.attackUntil = Date.now() + ms; }
  function getPlayerFrame() {
    const now = Date.now();
    if (now < playerAnim.attackUntil) return 4;
    if (now < playerAnim.walkUntil) return Math.floor(now / 140) % 4;
    return 0;
  }

  const BASE_SHOP_ITEMS = [
    { id: 'tong1',  name: 'éŒ†ã³ãŸãƒˆãƒ³ã‚°', type: 'atk', val: 5,   price: 500,   req: 0,   icon: 'ğŸ¥¢', category: 'gear' },
    { id: 'glove1', name: 'è»æ‰‹',         type: 'spd', val: 3,   price: 800,   req: 100, icon: 'ğŸ§¤', category: 'gear' },
    { id: 'pad1',   name: 'é˜²è­·ãƒ‘ãƒƒãƒ‰',   type: 'def', val: 8,   price: 2500,  req: 120, icon: 'ğŸ›¡ï¸', category: 'gear' },
    { id: 'tong2',  name: 'ãƒã‚¿ãƒ³ãƒˆãƒ³ã‚°', type: 'atk', val: 15,  price: 2000,  req: 150, icon: 'ğŸ¥¢', category: 'gear' },
    { id: 'suit',   name: 'é˜²è­·ã‚¹ãƒ¼ãƒ„',   type: 'hp',  val: 250, price: 18000, req: 600, icon: 'ğŸ¥‹', category: 'gear' },

    { id: 'bag_s',  name: 'ã‚´ãƒŸè¢‹(å°)',     price: 0,     req: 0,   icon: 'ğŸ—‘ï¸', category: 'bag', cap: 100 },
    { id: 'bag_m',  name: 'ã‚´ãƒŸè¢‹(ä¸­)',     price: 900,   req: 0,   icon: 'ğŸ—‘ï¸', category: 'bag', cap: 180 },
    { id: 'bag_l',  name: 'ã‚´ãƒŸè¢‹(å¤§)',     price: 2200,  req: 50,  icon: 'ğŸ—‘ï¸', category: 'bag', cap: 260 },
    { id: 'eco',    name: 'ã‚¨ã‚³ãƒãƒƒã‚°',     price: 1500,  req: 0,   icon: 'ğŸ›ï¸', category: 'bag', cap: 140 },
    { id: 'ruck',   name: 'ãƒªãƒ¥ãƒƒã‚¯ã‚µãƒƒã‚¯', price: 4800,  req: 100, icon: 'ğŸ’', category: 'bag', cap: 220 },
    { id: 'mobile', name: 'ç§»å‹•å¼ã‚´ãƒŸç®±',   price: 12000, req: 200, icon: 'ğŸš®', category: 'bag', cap: 420 }
  ];

  const ENEMIES = [
    { n: "è’ã¶ã‚‹ãƒ¬ã‚¸è¢‹",      h: 40,  a: 10, s: 2,  x: 25,  e: 'ğŸ›ï¸', imgKey: "enemy1", hpWeight: 0.35, atkWeight: 0.25 },
    { n: "æ”¾ç½®ã•ã‚ŒãŸãƒ†ãƒ¬ãƒ“",  h: 120, a: 25, s: 6,  x: 90,  e: 'ğŸ“º', imgKey: "enemy2", hpWeight: 0.65, atkWeight: 0.45 },
    { n: "ç²—å¤§ã‚´ãƒŸã®å¡Š",      h: 400, a: 50, s: 10, x: 350, e: 'ğŸ§Š', imgKey: "enemy3", hpWeight: 0.95, atkWeight: 0.65 }
  ];

  function saveGame() {
    try { localStorage.setItem('ecoTownSave', JSON.stringify(state)); }
    catch (e) { console.warn('Save failed', e); }
  }

  function loadGame() {
    try {
      const raw = localStorage.getItem('ecoTownSave');
      if (!raw) return;
      const loaded = JSON.parse(raw);
      if (!loaded || !loaded.player || !loaded.stats) return;

      state = loaded;

      if (!state.lastTick) state.lastTick = Date.now();
      if (!state.battle) state.battle = { isPlayerTurn: false, isAnimating: false, defending: false };
      if (!state.inventory) state.inventory = [];
      if (!state.staffCost) state.staffCost = 300;
      if (!state.loot) state.loot = { cur: 0, max: 100 };
      if (!state.player.bagId) state.player.bagId = 'bag_s';
      if (!state.lastDisasterAt) state.lastDisasterAt = 0;
      if (!state.placing) state.placing = { active: false, type: null };
      if (!state.patrol) state.patrol = { until: 0 };
      if (!state.dungeon) state.dungeon = { bossSpawned: false, bossDefeated: false, zeroUsed: false };
      if (state.dungeon.zeroUsed == null) state.dungeon.zeroUsed = false;
      if (!state.uiTab) state.uiTab = 'town';
      if (!state.mode) state.mode = 'town';

      if (state.player.baseDef == null) state.player.baseDef = 0;
      if (!state.player.equip) state.player.equip = { weapon: null, hand: null, body: null };

      // âœ… å´©å£Šãƒ•ã‚§ãƒ¼ã‚ºã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè£œå®Œ
      ensureCollapseState();

      if (state._supportMigrated_v2 == null) state._supportMigrated_v2 = false;
      migrateSupportsIfNeeded();
      ensureSupportState();

      if (state.supports?.inventory?.length) {
        state.supports.inventory.forEach(u => {
          if (u.dupes == null) u.dupes = 0;
          if (u.level == null) u.level = 1;
          if (u.exp == null) u.exp = 0;
        });
      }

      ensureDefaultBagOwned();
    } catch (e) {
      console.warn('Load failed', e);
    }
  }

  function enableAutoSave() { setInterval(saveGame, 5000); }

  function ensureDefaultBagOwned() {
    if (!state.inventory.some(i => i.id === 'bag_s')) state.inventory.push({ id: 'bag_s', plus: 0 });
  }

  function getEquippedBag() {
    const id = state.player.bagId || 'bag_s';
    return BASE_SHOP_ITEMS.find(i => i.id === id && i.category === 'bag') || BASE_SHOP_ITEMS.find(i => i.id === 'bag_s');
  }

  function updateLootMaxFromBag() {
    ensureDefaultBagOwned();
    const bag = getEquippedBag();
    const cap = bag?.cap ?? 100;
    state.loot.max = cap;
    state.loot.cur = Math.min(state.loot.max, state.loot.cur);
  }

  function equipBag(id) {
    const item = BASE_SHOP_ITEMS.find(i => i.id === id && i.category === 'bag');
    if (!item) return;
    if (!state.inventory.some(inv => inv.id === id)) return;

    state.player.bagId = id;
    updateLootMaxFromBag();
    logMessage(`è£…å‚™å¤‰æ›´ï¼š${item.name}ï¼ˆå®¹é‡ ${item.cap}ï¼‰`);
    updateUI();
    refreshShop();
  }

  function renderShop(){ refreshShop(); }
  function updateHUD(){ updateUI(); }

  function ensureEquipState(){
    if (!state.player) state.player = {};
    if (!state.player.equip) state.player.equip = { weapon: null, hand: null, body: null };
  }

  function gearSlotOf(id){
    if (id.startsWith("tong")) return "weapon";
    if (id.startsWith("glove")) return "hand";
    if (id === "pad1") return "body";
    if (id === "suit") return "body";
    return null;
  }

  function getEquippedGearIdSet(){
    ensureEquipState();
    const e = state.player.equip;
    return new Set([e.weapon, e.hand, e.body].filter(Boolean));
  }

  function getPlayerStats() {
    ensureEquipState();

    let bonus = { atk: 0, def: 0, spd: 0, luk: 0, hp: 0 };
    const equipped = getEquippedGearIdSet();

    state.inventory.forEach(inv => {
      const base = BASE_SHOP_ITEMS.find(i => i.id === inv.id);
      if (!base) return;
      if (base.category === 'bag') return;

      if (!equipped.has(inv.id)) return;

      const mul = 1 + ((inv.plus ?? 0) * 0.2);
      if (base.type) {
        if (bonus[base.type] == null) bonus[base.type] = 0;
        bonus[base.type] += Math.floor((base.val || 0) * mul);
      }
    });

    const s = calcSupportBonus();

    return {
      atk: state.player.baseAtk + bonus.atk + s.atk,
      def: state.player.baseDef + bonus.def + s.def,
      spd: state.player.baseSpd + bonus.spd + s.spd,
      luk: state.player.baseLuk + bonus.luk,
      maxHp: state.player.maxHp + bonus.hp + s.maxHp
    };
  }

  function toggleEquipGear(id) {
    ensureEquipState();
    const slot = gearSlotOf(id);
    if (!slot) return;

    const cur = state.player.equip[slot];
    state.player.equip[slot] = (cur === id) ? null : id;

    updateEquipUI();
  }

  function updateEquipUI() {
    updateEquipTextUI();
    renderShop();
    updateHUD();
  }

  function updateEquipTextUI() {
    ensureEquipState();
    const e = state.player.equip;

    const nameOf = (id) => {
      if (!id) return "-";
      const it = BASE_SHOP_ITEMS.find(x => x.id === id);
      return it ? it.name : "-";
    };

    const w = document.getElementById("eq-weapon");
    const h = document.getElementById("eq-hand");
    const b = document.getElementById("eq-body");
    if (w) w.innerText = nameOf(e.weapon);
    if (h) h.innerText = nameOf(e.hand);
    if (b) b.innerText = nameOf(e.body);
  }

  function getTownProgressLevel() {
    if (state.population < 120) return 0;
    if (state.population < 160) return 1;
    if (state.population < 220) return 2;
    if (state.population < 300) return 3;
    return 4;
  }

  function applyTownGrowth() {
    const lv = getTownProgressLevel();

    townMap = Array.from({ length: TOWN_H }, () =>
      Array.from({ length: TOWN_W }, () => TILE_GRASS)
    );

    const midY = Math.floor(TOWN_H / 2);
    const midX = Math.floor(TOWN_W / 2);

    for (let x = 0; x < TOWN_W; x++) townMap[midY][x] = TILE_ROAD;

    if (lv >= 1) for (let y = 0; y < TOWN_H; y++) townMap[y][midX] = TILE_ROAD;

    if (lv >= 2) {
      const x1 = Math.max(1, midX - 4);
      const x2 = Math.min(TOWN_W - 2, midX + 4);
      for (let y = 0; y < TOWN_H; y++) {
        townMap[y][x1] = TILE_ROAD;
        townMap[y][x2] = TILE_ROAD;
      }
    }

    if (lv >= 3) {
      const y1 = Math.max(1, midY - 2);
      const y2 = Math.min(TOWN_H - 2, midY + 2);
      for (let x = 0; x < TOWN_W; x++) {
        townMap[y1][x] = TILE_ROAD;
        townMap[y2][x] = TILE_ROAD;
      }
    }

    if (lv >= 4) {
      townMap[1][1] = TILE_ROAD;
      townMap[1][TOWN_W - 2] = TILE_ROAD;
      townMap[TOWN_H - 2][1] = TILE_ROAD;
      townMap[TOWN_H - 2][TOWN_W - 2] = TILE_ROAD;
    }

    applyBuildingGrowth();
  }

  function neighborsAreRoad(x, y) {
    const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
    return dirs.some(([dx,dy]) => {
      const nx = x + dx, ny = y + dy;
      if (nx < 0 || nx >= TOWN_W || ny < 0 || ny >= TOWN_H) return false;
      return townMap[ny][nx] === TILE_ROAD;
    });
  }

  function getBuildingTierByPop(pop) {
    if (pop < 140) return 0;
    if (pop < 220) return 1;
    if (pop < 320) return 2;
    return 3;
  }

  function pickBuildingForTier(tier) {
    const r = Math.random();
    if (tier === 0) return BLD_HUT;
    if (tier === 1) return (r < 0.75) ? BLD_HOUSE : BLD_APT;
    if (tier === 2) {
      if (r < 0.15) return BLD_HOUSE;
      if (r < 0.80) return BLD_APT;
      return BLD_BIG;
    }
    if (r < 0.25) return BLD_HOUSE;
    if (r < 0.70) return BLD_APT;
    return BLD_BIG;
  }

  function applyBuildingGrowth() {
    for (let y = 0; y < TOWN_H; y++) for (let x = 0; x < TOWN_W; x++) {
      if (townMap[y][x] === TILE_ROAD && !isFacilityTile(buildingMap[y][x])) buildingMap[y][x] = BLD_EMPTY;
    }

    const tier = getBuildingTierByPop(state.population);
    const targetBuildings = Math.min((tier + 1) * 10, Math.floor(state.population / 25));

    let current = 0;
    for (let y = 0; y < TOWN_H; y++) for (let x = 0; x < TOWN_W; x++) {
      if (townMap[y][x] !== TILE_ROAD && buildingMap[y][x] !== BLD_EMPTY && !isFacilityTile(buildingMap[y][x])) current++;
    }

    if (current < targetBuildings) {
      const need = targetBuildings - current;
      let placed = 0;

      const candidatesNearRoad = [];
      const candidatesAny = [];
      for (let y = 0; y < TOWN_H; y++) for (let x = 0; x < TOWN_W; x++) {
        if (townMap[y][x] === TILE_ROAD) continue;
        if (buildingMap[y][x] !== BLD_EMPTY) continue;
        (neighborsAreRoad(x,y) ? candidatesNearRoad : candidatesAny).push([x,y]);
      }

      function pick(list) {
        if (list.length === 0) return null;
        const i = Math.floor(Math.random() * list.length);
        return list.splice(i,1)[0];
      }

      while (placed < need) {
        const pos = pick(candidatesNearRoad) || pick(candidatesAny);
        if (!pos) break;
        const [x,y] = pos;

        const env = state.stats.env;
        const roll = Math.random();

        if (env >= 85 && roll < 0.12) {
          buildingMap[y][x] = (Math.random() < 0.5) ? BLD_TREE : BLD_PARK;
        } else {
          buildingMap[y][x] = pickBuildingForTier(tier);
        }
        placed++;
      }
    }

    if (current > targetBuildings + 4) {
      const removeCount = Math.min(3, current - targetBuildings);
      let removed = 0;
      for (let tries = 0; tries < 200 && removed < removeCount; tries++) {
        const x = Math.floor(Math.random() * TOWN_W);
        const y = Math.floor(Math.random() * TOWN_H);
        if (townMap[y][x] === TILE_ROAD) continue;
        if (buildingMap[y][x] === BLD_EMPTY) continue;
        if (isFacilityTile(buildingMap[y][x])) continue;

        if (buildingMap[y][x] === BLD_TREE && Math.random() < 0.7) continue;
        buildingMap[y][x] = BLD_EMPTY;
        removed++;
      }
    }
  }

  function getTownDrawGeo() {
    const padding = 8;
    const usableW = canvas.width - padding * 2;
    const usableH = canvas.height - padding * 2;

    const tileDrawSize = Math.floor(Math.min(usableW / TOWN_W, usableH / TOWN_H));
    if (tileDrawSize <= 0) return null;

    const mapWpx = tileDrawSize * TOWN_W;
    const mapHpx = tileDrawSize * TOWN_H;

    const ox = Math.floor((canvas.width - mapWpx) / 2);
    const oy = Math.floor((canvas.height - mapHpx) / 2);
    return { ox, oy, tileDrawSize, mapWpx, mapHpx };
  }

  function drawTownTiles() {
    const geo = getTownDrawGeo();
    if (!geo) return;
    const { ox, oy, tileDrawSize } = geo;

    for (let y = 0; y < TOWN_H; y++) {
      for (let x = 0; x < TOWN_W; x++) {
        const t = townMap[y][x];
        const dx = ox + x * tileDrawSize;
        const dy = oy + y * tileDrawSize;

        if (t === TILE_ROAD) {
          drawTileSheet(ROAD_TILES, 1, dx, dy, tileDrawSize, tileDrawSize, "#2a2a2a");
        } else {
          ctx.fillStyle = "#173a1d";
          ctx.fillRect(dx, dy, tileDrawSize, tileDrawSize);
        }

        const b = buildingMap[y][x];
        if (t !== TILE_ROAD && b !== BLD_EMPTY) {
          if (isFacilityTile(b)) {
            const civicId = civicTileIdOfBuildingId(b);
            drawTileSheet(CIVIC_TILES, civicId, dx, dy, tileDrawSize, tileDrawSize, "#444");
          } else {
            drawTileSheet(BUILD_TILES, b, dx, dy, tileDrawSize, tileDrawSize, "#444");
          }

          if (infected[y][x] > 0) {
            ctx.save();
            ctx.globalAlpha = 0.85;
            ctx.font = `${Math.floor(tileDrawSize * 0.9)}px 'DotGothic16', monospace`;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText("â˜£", dx + tileDrawSize / 2, dy + tileDrawSize / 2);
            ctx.restore();
          }
        }
      }
    }
  }

  function waste01() {
    const wr = state?.wasteRate ?? 0;
    return clamp(wr / ENEMY_WASTE_SCALE_MAX, 0, 1);
  }
  function getEnemyBoost(enemyBase) {
    const w = waste01();
    const hpBoost  = 1 + (ENEMY_HP_BOOST_MAX  * w * (enemyBase.hpWeight ?? 0.55));
    const atkBoost = 1 + (ENEMY_ATK_BOOST_MAX * w * (enemyBase.atkWeight ?? 0.35));
    return { w, hpBoost, atkBoost };
  }
  function spawnEnemy(enemyBase) {
    const boost = getEnemyBoost(enemyBase);
    const maxH = Math.max(1, Math.floor(enemyBase.h * boost.hpBoost));
    const a    = Math.max(1, Math.floor(enemyBase.a * boost.atkBoost));
    return { ...enemyBase, maxH, curH: maxH, a, boost };
  }

  function getEnvBarrierRate() {
    const units = getEquippedSupports();
    const mirako = units.find(u => u.masterId === "mirako");
    if (!mirako) return 0;
    const r = mirako.rarity ?? 1;
    if (r === 1) return 0.10;
    if (r === 2) return 0.15;
    if (r === 3) return 0.20;
    if (r === 4) return 0.30;
    if (r >= 5) return 0.40;
    return 0;
  }

  function simulateCityTick({ isOffline = false } = {}) {
    const eff = getFacilityEffects();
    const envBarrier = getEnvBarrierRate();

    state.wasteRate += state.population / 400;

    let clean = state.staff * 0.9;
    if (!isOffline && state.mode !== 'town') clean *= 2.0;
    state.wasteRate = Math.max(0, state.wasteRate - clean);

    if (state.wasteRate > 5.0) state.stats.env -= 0.5 * (1 - envBarrier);
    else if (state.wasteRate < 1.0) state.stats.env += 0.3;

    if (state.wasteRate > 4.0) {
      state.stats.security -= 0.35;
      state.stats.health   -= 0.25;
    } else if (state.wasteRate < 1.2) {
      state.stats.security += 0.15;
      state.stats.health   += 0.15;
    }

    state.stats.security += eff.securityRegen;

    // âœ… ãƒ‘ãƒˆãƒ­ãƒ¼ãƒ«ä¸­ã¯æ²»å®‰å›å¾©ãŒå¢—ãˆã‚‹
    if (isPatrolActive()) {
      state.stats.security += PATROL_REGEN_BONUS;
    }

    state.stats.health += eff.healthRegen;

    if (state.wasteRate > 12) state.population = Math.max(10, state.population - 4);
    else if (state.wasteRate > 6) state.population = Math.max(10, state.population - 2);

    if (state.stats.env > 80) state.population += Math.floor(state.population * 0.01) + 1;
    else if (state.stats.env < 40) state.population = Math.max(10, state.population - 2);

    let incomeMul = 1.0;
    if (state.stats.security < 40) incomeMul *= 0.8;
    if (state.stats.health   < 40) incomeMul *= 0.85;
    state.money += Math.floor(state.population * 0.2 * incomeMul);

    Object.keys(state.stats).forEach(k => state.stats[k] = clamp(state.stats[k], 0, 100));

    for (let y = 0; y < TOWN_H; y++) for (let x = 0; x < TOWN_W; x++) {
      if (infected[y][x] > 0) infected[y][x] = Math.max(0, infected[y][x] - 1);
    }
  }

  function applyOfflineProgress() {
    const now  = Date.now();
    const last = state.lastTick || now;
    let diffSec = Math.floor((now - last) / 1000);
    diffSec = Math.max(0, Math.min(diffSec, 12 * 60 * 60));
    for (let i = 0; i < diffSec; i++) {
      simulateCityTick({ isOffline: true });
      applyTownGrowth();
    }
    state.lastTick = now;
  }

  function mainLoopTick() {
    simulateCityTick({ isOffline: false });

    // âœ… å´©å£Šãƒ•ã‚§ãƒ¼ã‚ºï¼šåˆ¤å®šï¼†å´©å£Šä¸­å‡¦ç†ï¼ˆæ¯ç§’ï¼‰
    checkCollapseTriggers();
    applyCollapseTick();

    state.lastTick = Date.now();
    applyTownGrowth();
    updateUI();
    if (document.getElementById('tab-shop')?.classList.contains('active')) refreshShop();
  }

  function updateUI() {
    ensureSupportState();
    ensureCollapseState();
    updateLootMaxFromBag();
    updateAssetStatus();
    updateEquipTextUI();

    const ps = getPlayerStats();
    state.player.hp = clamp(state.player.hp, 0, ps.maxHp);

    document.getElementById('ui-money').innerText = Math.floor(state.money).toLocaleString();
    document.getElementById('ui-pop').innerText   = Math.floor(state.population);
    document.getElementById('ui-waste').innerText = state.wasteRate.toFixed(1);

    document.getElementById('bar-env').style.width  = `${state.stats.env}%`;
    document.getElementById('bar-sec').style.width  = `${state.stats.security}%`;
    document.getElementById('bar-heal').style.width = `${state.stats.health}%`;

    document.getElementById('val-env').innerText  = Math.floor(state.stats.env);
    document.getElementById('val-sec').innerText  = Math.floor(state.stats.security);
    document.getElementById('val-heal').innerText = Math.floor(state.stats.health);

    document.getElementById('st-atk').innerText = ps.atk;
    document.getElementById('st-def').innerText = ps.def;
    document.getElementById('st-spd').innerText = ps.spd;
    document.getElementById('st-luk').innerText = ps.luk;

    const hpPercent = ps.maxHp > 0 ? (state.player.hp / ps.maxHp) * 100 : 0;
    document.getElementById('ui-hp-text').innerText = `${Math.ceil(state.player.hp)}/${ps.maxHp}`;
    document.getElementById('hp-bar').style.width   = `${hpPercent}%`;

    document.getElementById('battle-player-hp-bar').style.width = `${hpPercent}%`;
    document.getElementById('battle-player-hp-text').innerText  = `${Math.ceil(state.player.hp)}/${ps.maxHp}`;

    document.getElementById('ui-lv').innerText = state.player.lv;
    document.getElementById('ui-xp').innerText = Math.max(0, state.player.next - state.player.xp);

    const btnDrink = document.getElementById('btn-drink');
    if (btnDrink) btnDrink.innerText = `ğŸ§ª ãƒœãƒˆãƒ«(${state.player.drinks})`;

    document.getElementById('staff-cost').innerText = `${state.staffCost}G`;

    document.getElementById('ui-clean').innerText = (state.staff * 0.9).toFixed(1);
    document.getElementById('ui-staff').innerText = state.staff;

    const lootCur = state.loot?.cur ?? 0;
    const lootMax = state.loot?.max ?? 100;
    const lootPct = lootMax > 0 ? (lootCur / lootMax) * 100 : 0;
    document.getElementById('ui-loot').innerText = Math.floor(lootCur);
    document.getElementById('ui-loot-max').innerText = Math.floor(lootMax);
    document.getElementById('loot-bar').style.width = `${clamp(lootPct,0,100)}%`;

    const bag = getEquippedBag();
    document.getElementById('ui-bag-name').innerText = bag ? `${bag.name}ï¼ˆ${bag.cap}ï¼‰` : '-';

    document.getElementById('place-hint').classList.toggle('hidden', !state.placing.active);

    const enemyHpText = document.getElementById('enemy-hp-text');
    if (enemyHpText) {
      if (state.mode === 'battle' && state.enemy) {
        enemyHpText.innerText = `${Math.max(0, Math.ceil(state.enemy.curH))}/${Math.max(1, Math.ceil(state.enemy.maxH))}`;
      } else {
        enemyHpText.innerText = `0/0`;
      }
    }

    // å´©å£Šæ¼”å‡ºã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã®è‡ªç„¶æ¶ˆç¯
    tickCollapseOverlay();

    setActiveNav(state.uiTab);
  }

  function setActiveNav(tab) {
    const ids = ["town","shop","explore"];
    for (const t of ids) {
      const btn = document.getElementById("nav-"+t);
      if (!btn) continue;
      btn.classList.toggle("bg-gray-200", tab === t);
    }
  }

  function showTab(t) {
    if (state.mode !== 'town' && t !== 'explore') {
      logMessage("é å¾ä¸­ã¯è¡—/åº—ã«æˆ»ã‚Œã¾ã›ã‚“ã€‚ã€æ’¤é€€ã€ã—ã¦ãã ã•ã„ã€‚");
      return;
    }

    if (t !== 'town') cancelPlacing();

    state.uiTab = t;

    document.querySelectorAll('.tab-content').forEach(el => el.classList.remove('active'));
    document.getElementById('tab-' + t).classList.add('active');

    if (t === 'shop') refreshShop();
    updateUI();
  }

  function applyMirakoDrinkBonusOnStart() {
    const units = getEquippedSupports();
    const mirako = units.find(u => u.masterId === "mirako");
    if (!mirako) return;
    const r = mirako.rarity ?? 1;
    if (r < 4) return;

    const add = (r >= 5) ? 2 : 1;
    state.player.drinks = Math.min(5, (state.player.drinks ?? 0) + add);
    logMessage(`ğŸŒ¸ å›å¾©ã®å¿œæ´ãƒ‰ãƒªãƒ³ã‚¯ï¼ ãƒœãƒˆãƒ« +${add}ï¼ˆæœ€å¤§5ï¼‰`);
  }

  function startDungeon() {
    cancelPlacing();
    state.mode = 'dungeon';
    state.uiTab = 'explore';

    state.distance = 0;
    state.loot.cur = 0;
    state.dungeon = { bossSpawned: false, bossDefeated: false, zeroUsed: false };

    applyMirakoDrinkBonusOnStart();

    document.getElementById('ui-town-ctrl').classList.add('hidden');
    document.getElementById('ui-dungeon-ctrl').classList.remove('hidden');
    document.getElementById('ui-battle-ctrl').classList.add('hidden');
    document.getElementById('battle-hud').classList.add('hidden');

    playWalk(650);
    logMessage("ä¸æ³•æŠ•æ£„ã‚¨ãƒªã‚¢ã®æ¢ç´¢ã‚’é–‹å§‹ã—ãŸã€‚");
    showTab('explore');
    updateUI();
  }

  function tryFromZeroRescueAndReturn() {
    const units = getEquippedSupports();
    const fz = units.find(u => u.masterId === "fromzero");
    const can = fz && (fz.rarity ?? 1) >= 4 && !(state.dungeon?.zeroUsed);

    if (!can) return false;

    state.dungeon.zeroUsed = true;
    state.player.hp = 1;
    state.loot.cur = 0;
    logMessage("ğŸ§¹ ã‚¼ãƒ­ã‹ã‚‰ã®ã‚¹ã‚¿ãƒ¼ãƒˆï¼ HP1ã§è¸ã¿ã¨ã©ã¾ã‚Šã€æˆ¦åˆ©å“0ã§å¸°é‚„ï¼");
    returnTown(true);
    updateUI();
    return true;
  }

  function dungeonStep() {
    state.distance++;
    state.player.hp -= 1;

    if (!state.dungeon.bossDefeated && !state.dungeon.bossSpawned && state.distance >= BOSS_DISTANCE_STEP) {
      logMessage("ğŸš¨ 200måˆ°é”â€¦æ•‘æ¸ˆãƒœã‚¹ãŒå‡ºç¾ã—ãŸï¼");
      startBattle({ isBoss: true });
      updateUI();
      return;
    }

    const gain = 6 + Math.floor(Math.random() * 8);
    state.loot.cur = Math.min(state.loot.max, state.loot.cur + gain);

    playWalk(450);

    if (Math.random() < 0.3) startBattle();
    else logMessage(`${state.distance}0m åœ°ç‚¹ã€‚ç•°å¸¸ãªã—ã€‚`);

    if (state.player.hp <= 0) {
      if (tryFromZeroRescueAndReturn()) return;
      openModal("é å¾å¤±æ•—ï¼è³‡é‡‘ã®ä¸€éƒ¨ã‚’å¤±ã„ã¾ã—ãŸã€‚ï¼ˆå›åã‚‚å¤±ã„ã¾ã™ï¼‰");
      state.money = Math.floor(state.money * 0.8);
      state.loot.cur = 0;
      state.player.hp = getPlayerStats().maxHp;
      returnTown(true);
      return;
    }

    updateUI();
  }

  function startBattle({ isBoss = false } = {}) {
    state.mode = 'battle';

    let base;
    if (isBoss) {
      base = BOSS;
      state.dungeon.bossSpawned = true;
    } else {
      const idx = Math.min(ENEMIES.length - 1, Math.floor(state.distance / 10));
      base = ENEMIES[idx];
    }

    state.enemy = spawnEnemy(base);
    state.enemy.isBoss = isBoss;

    document.getElementById('ui-dungeon-ctrl').classList.add('hidden');
    document.getElementById('ui-battle-ctrl').classList.remove('hidden');
    document.getElementById('battle-hud').classList.remove('hidden');

    const w = state.enemy.boost?.w ?? 0;
    const suffix = isBoss ? "ï¼ˆæ•‘æ¸ˆãƒœã‚¹ï¼‰" : (w >= 0.8 ? "ï¼ˆçŒ›æ¯’æ±šæŸ“ï¼‰" : w >= 0.5 ? "ï¼ˆæ±šæŸ“ï¼‰" : w >= 0.25 ? "ï¼ˆè»½æ±šæŸ“ï¼‰" : "");
    document.getElementById('enemy-name').innerText = `${isBoss ? "BOSSï¼š" : ""}${state.enemy.n}${suffix}`;

    const hpBar = document.getElementById('enemy-hp-bar');
    hpBar.style.transition = 'none';
    hpBar.style.width = '100%';
    hpBar.offsetHeight;
    hpBar.style.transition = '';

    const ps = getPlayerStats();
    if (ps.spd >= state.enemy.s) {
      state.battle.isPlayerTurn = true;
      logMessage(isBoss ? "ãƒœã‚¹æˆ¦ï¼ã‚ãªãŸã®å…ˆåˆ¶æ”»æ’ƒï¼" : "ã‚ãªãŸã®å…ˆåˆ¶æ”»æ’ƒï¼");
    } else {
      state.battle.isPlayerTurn = false;
      setTimeout(enemyTurn, 800);
    }

    updateUI();
  }

  function battleTurn(action) {
    if (state.mode !== 'battle') return;
    if (!state.battle.isPlayerTurn || state.battle.isAnimating) return;

    const ps = getPlayerStats();

    if (action === 'attack') {
      playAttack(300);

      const cc = critChance(ps.luk);
      const isCrit = Math.random() < cc;
      const dmg = isCrit ? Math.floor(ps.atk * 1.6) : ps.atk;

      state.enemy.curH -= dmg;
      createFloatingText(isCrit ? `CRIT! -${dmg}` : `-${dmg}`, "#fff", 60);
      logMessage(isCrit ? `${state.enemy.n}ã«ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ï¼` : `${state.enemy.n}ã«ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼`);
    } else if (action === 'defend') {
      state.battle.defending = true;
      logMessage("èº«ã‚’è­·ã£ã¦ã„ã‚‹...ï¼ˆæ¬¡ã®è¢«ãƒ€ãƒ¡è»½æ¸›UPï¼‰");
    } else if (action === 'heal') {
      if (state.player.drinks > 0) {
        state.player.drinks--;
        state.player.hp = Math.min(ps.maxHp, state.player.hp + 100);
        logMessage("ãƒœãƒˆãƒ«ã§å›å¾©ã—ãŸï¼");
      } else {
        logMessage("ãƒœãƒˆãƒ«ãŒãªã„ï¼");
        return;
      }
    } else if (action === 'flee') {
      if (Math.random() < 0.5) { endBattle({ won: false }); return; }
      logMessage("é€ƒã’ã‚‰ã‚Œãªã‹ã£ãŸï¼");
    }

    state.enemy.curH = Math.max(0, state.enemy.curH);
    document.getElementById('enemy-hp-bar').style.width = `${(state.enemy.curH / state.enemy.maxH) * 100}%`;

    if (state.enemy.curH <= 0) {
      const lootBonus = Math.floor(ps.atk * 0.05) + Math.floor(ps.luk * 0.2);
      const lootReward = Math.floor(state.enemy.maxH * 0.8 + (Math.random() * 8)) + lootBonus;

      gainXp(state.enemy.x);
      endBattle({ won: true, lootReward, isBoss: !!state.enemy?.isBoss });
    } else {
      state.battle.isPlayerTurn = false;
      setTimeout(enemyTurn, 800);
    }

    updateUI();
  }

  function enemyTurn() {
    if (state.mode !== 'battle') return;

    const ps = getPlayerStats();

    const dc = dodgeChance(ps.spd, state.enemy.s);
    if (Math.random() < dc) {
      createFloatingText("MISS!", "#6ee7b7", 40);
      logMessage(`${state.enemy.n}ã®æ”»æ’ƒï¼â€¦ã—ã‹ã—é¿ã‘ãŸï¼`);
      state.battle.isPlayerTurn = true;
      updateUI();
      return;
    }

    const raw = state.enemy.a;
    const effDef = state.battle.defending ? ps.def * 2 : ps.def;
    const dmg = reduceDamage(raw, effDef);

    state.battle.defending = false;
    state.player.hp -= dmg;

    createFloatingText(`-${dmg}`, "#f00", 40);
    logMessage(`${state.enemy.n}ã®æ”»æ’ƒï¼`);

    if (state.player.hp <= 0) {
      if (tryFromZeroRescueAndReturn()) return;
      openModal("é å¾å¤±æ•—ï¼è³‡é‡‘ã®ä¸€éƒ¨ã‚’å¤±ã„ã¾ã—ãŸã€‚ï¼ˆå›åã‚‚å¤±ã„ã¾ã™ï¼‰");
      state.money = Math.floor(state.money * 0.8);
      state.loot.cur = 0;
      state.player.hp = getPlayerStats().maxHp;
      returnTown(true);
      return;
    }

    state.battle.isPlayerTurn = true;
    updateUI();
  }

  function animateLootGain(amount, duration = 900) {
    const from = Number(state.loot.cur || 0);
    const to = Math.min(state.loot.max, from + amount);
    const start = performance.now();

    function step(now) {
      const t = Math.min(1, (now - start) / duration);
      state.loot.cur = from + (to - from) * t;
      updateUI();
      if (t < 1) requestAnimationFrame(step);
      else { state.loot.cur = to; updateUI(); }
    }
    requestAnimationFrame(step);
  }

  function endBattle(result = { won: false, lootReward: 0, isBoss: false }) {
    if (result.won && result.isBoss) {
      document.getElementById('ui-battle-ctrl').classList.add('hidden');
      document.getElementById('battle-hud').classList.add('hidden');

      if (result.lootReward > 0) {
        logMessage(`ãƒœã‚¹æ’ƒç ´ï¼å›åï¼ +${result.lootReward}`);
        animateLootGain(result.lootReward, 900);
      } else {
        logMessage("ãƒœã‚¹æ’ƒç ´ï¼");
      }

      const before = state.wasteRate;
      state.wasteRate = Math.max(0, state.wasteRate * (1 - BOSS_WASTE_REDUCE_RATE));
      const reduced = before - state.wasteRate;

      state.dungeon.bossDefeated = true;

      // âœ… åˆå›ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«æ‰±ã„ï¼šæ•‘æ¸ˆãƒœã‚¹æ’ƒç ´ = tutorialBossDefeated
      ensureCollapseState();
      if (!state.collapse.enteredOnce) {
        state.collapse.tutorialBossDefeated = true;
      }

      state.enemy = null;

      setTimeout(() => {
        logMessage(`ğŸ‘‘ æ•‘æ¸ˆç™ºå‹•ï¼šè¡—ã®ã‚´ãƒŸ -30%ï¼ˆ-${reduced.toFixed(1)}ï¼‰â†’ å¼·åˆ¶å¸°é‚„`);
        returnTown(false);
        updateUI();
      }, 650);

      return;
    }

    state.mode = 'dungeon';
    document.getElementById('ui-battle-ctrl').classList.add('hidden');
    document.getElementById('ui-dungeon-ctrl').classList.remove('hidden');
    document.getElementById('battle-hud').classList.add('hidden');

    if (result.won && result.lootReward > 0) {
      logMessage(`æˆ¦é—˜çµ‚äº†ã€‚å›åï¼ +${result.lootReward}`);
      animateLootGain(result.lootReward, 900);
    } else {
      logMessage("æˆ¦é—˜çµ‚äº†ã€‚æ¢ç´¢ã‚’å†é–‹ã—ã¾ã™ã€‚");
    }

    state.enemy = null;
    playWalk(650);
    updateUI();
  }

  function gainXp(amt) {
    state.player.xp += amt;
    if (state.player.xp >= state.player.next) {
      state.player.lv++;
      state.player.xp = 0;
      state.player.next = Math.floor(state.player.next * 1.5);

      state.player.maxHp += 20;
      state.player.baseAtk += 5;
      state.player.baseDef += 3;
      state.player.baseSpd += 1;
      state.player.baseLuk += 1;

      state.player.hp = getPlayerStats().maxHp;
      openModal(`LEVEL UP! LV.${state.player.lv}ã«ãªã£ãŸï¼\nATK+5 DEF+3 SPD+1 LUK+1 HP+20`);
    }
  }

  function applyReturnCleanup(lootAmount) {
    const reduced = lootAmount * CITY_WASTE_REDUCTION_PER_LOOT;
    state.wasteRate = Math.max(0, state.wasteRate - reduced);
    return reduced;
  }

  function returnTown(isForced = false) {
    if (!isForced && state.loot && state.loot.cur > 0) {
      const lootAmount = Math.floor(state.loot.cur);
      const reward = Math.floor(lootAmount * MONEY_PER_LOOT);
      state.money += reward;

      const reduced = applyReturnCleanup(lootAmount);
      logMessage(`å¸°é‚„ï¼šæ›é‡‘ +${reward}G / è¡—ã®ã‚´ãƒŸ -${reduced.toFixed(1)}`);
      state.loot.cur = 0;
    } else {
      state.loot.cur = 0;
      logMessage("æ’¤é€€ã—ã¾ã—ãŸã€‚");
    }

    state.mode = 'town';

    document.getElementById('ui-town-ctrl').classList.remove('hidden');
    document.getElementById('ui-dungeon-ctrl').classList.add('hidden');
    document.getElementById('ui-battle-ctrl').classList.add('hidden');
    document.getElementById('battle-hud').classList.add('hidden');

    showTab('town');
    updateUI();
    refreshShop();
  }

  function refreshShop() {
    const container = document.getElementById('shop-items');
    if (!container) return;

    ensureDefaultBagOwned();
    ensureEquipState();

    container.innerHTML = '';

    const equippedSet = getEquippedGearIdSet();

    BASE_SHOP_ITEMS.forEach(item => {
      const isUnlocked = state.population >= (item.req || 0);
      const isOwned = state.inventory.some(i => i.id === item.id);
      const isBag = item.category === 'bag';

      let btnClass = "btn-action w-full flex justify-between items-center";
      let labelRight = '';
      let onclick = '';

      if (isBag) {
        const isEquipped = (state.player.bagId === item.id);

        if (!isUnlocked) {
          btnClass += " disabled";
          labelRight = `äººå£${item.req}å¿…è¦`;
          onclick = "void(0)";
        } else if (!isOwned) {
          if (state.money < item.price) btnClass += " disabled";
          labelRight = `${item.price}G`;
          onclick = `buyItem('${item.id}')`;
        } else {
          labelRight = isEquipped ? "è£…å‚™ä¸­" : "æ‰€æŒ(ã‚¿ãƒƒãƒ—ã§è£…å‚™)";
          onclick = `equipBag('${item.id}')`;
        }

        const leftText = `${item.icon} ${item.name}ï¼ˆå®¹é‡${item.cap}ï¼‰`;
        const div = document.createElement('div');
        div.innerHTML = `<button onclick="${onclick}" class="${btnClass}">
          <span>${leftText}</span>
          <span>${labelRight}</span>
        </button>`;
        container.appendChild(div);
        return;
      }

      const isEquipped = equippedSet.has(item.id);

      if (!isUnlocked) {
        btnClass += " disabled";
        labelRight = `äººå£${item.req}å¿…è¦`;
        onclick = "void(0)";
      } else if (!isOwned) {
        if (state.money < item.price) btnClass += " disabled";
        labelRight = `${item.price}G`;
        onclick = `buyItem('${item.id}')`;
      } else {
        labelRight = isEquipped ? "è£…å‚™ä¸­(è§£é™¤)" : "æ‰€æŒ(è£…å‚™)";
        onclick = `toggleEquipGear('${item.id}')`;
      }

      const leftText = `${item.icon} ${item.name}`;
      const div = document.createElement('div');
      div.innerHTML = `<button onclick="${onclick}" class="${btnClass}">
        <span>${leftText}</span>
        <span>${labelRight}</span>
      </button>`;
      container.appendChild(div);
    });
  }

  function buyItem(id) {
    const item = BASE_SHOP_ITEMS.find(i => i.id === id);
    if (!item) return;

    const isOwned = state.inventory.some(i => i.id === id);
    if (isOwned) return;

    if (state.money >= (item.price || 0)) {
      state.money -= (item.price || 0);
      state.inventory.push({ id: id, plus: 0 });

      if (item.category === 'bag') {
        state.player.bagId = id;
        updateLootMaxFromBag();
        logMessage(`è³¼å…¥ï¼†è£…å‚™ï¼š${item.name}ï¼ˆå®¹é‡ ${item.cap}ï¼‰`);
      } else {
        logMessage(`è³¼å…¥ï¼š${item.name}`);
      }

      updateUI();
      refreshShop();
    }
  }

  function buyUpgrade(type) {
    if (type === 'park' && state.money >= 1000) {
      state.money -= 1000;
      state.stats.env = Math.min(100, state.stats.env + 20);
      logMessage("â›² å…¬åœ’æ•´å‚™ï¼šç’°å¢ƒãŒæ”¹å–„ã—ãŸï¼");
    } else if (type === 'medical' && state.money >= 2500) {
      state.money -= 2500;
      state.stats.health = Math.min(100, state.stats.health + 20);
      logMessage("ğŸ’Š åŒ»ç™‚æŠ•è³‡ï¼šå¥åº·ãŒæ”¹å–„ã—ãŸï¼");
    }
    updateUI();
  }

  function recruitStaff() {
    if (state.money >= state.staffCost) {
      state.money -= state.staffCost;
      state.staff++;
      state.staffCost = Math.floor(state.staffCost * 1.4);
      logMessage("ğŸ§¹ æ¸…æƒå“¡ã‚’é›‡ç”¨ã—ãŸï¼");
      updateUI();
    }
  }

  function useDrink() {
    const ps = getPlayerStats();
    if (state.player.drinks > 0 && state.player.hp < ps.maxHp) {
      state.player.drinks--;
      state.player.hp = Math.min(ps.maxHp, state.player.hp + 100);
      updateUI();
    }
  }

  function logMessage(m) {
    const el = document.getElementById('game-log');
    if (el) el.innerText = m;
  }

  function createFloatingText(t, c, x) {
    const div = document.createElement('div');
    div.innerText = t;
    div.className = 'floating-text';
    div.style.left = `${x}%`;
    div.style.top = `40%`;
    div.style.color = c;
    document.getElementById('screen-container').appendChild(div);
    setTimeout(() => div.remove(), 1200);
  }

  function openModal(txt) {
    document.getElementById('modal-text').innerText = txt;
    document.getElementById('custom-modal').style.display = 'flex';
  }
  function closeModal() {
    document.getElementById('custom-modal').style.display = 'none';
  }

  function simulateAdReward() {
    openModal("å‹•ç”»åºƒå‘Šã‚’è¦–è´ã—ã¾ã—ãŸï¼ãƒœãƒ¼ãƒŠã‚¹ã¨ã—ã¦500Gç²å¾—ï¼");
    state.money += 500;
    updateUI();
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const env = state.stats.env / 100;
    ctx.fillStyle = `rgb(${40 - (env * 20)}, ${50 + (env * 50)}, ${80 + (env * 50)})`;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.fillStyle = '#0d0d0d';
    ctx.fillRect(0, 160, canvas.width, 40);

    const px = Math.floor(canvas.width * 0.55);
    const py = 200 - 40 - (PLAYER_SPR.ready ? (PLAYER_SPR.frameH * PLAYER_SPR.scale) : 0) + 18;

    if (state.mode === 'town') {
      drawTownTiles();
      drawPlayerFrame(0, px, py);
    } else if (state.mode === 'dungeon') {
      ctx.fillStyle = "rgba(0,0,0,0.25)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      drawPlayerFrame(getPlayerFrame(), px, py);
    } else if (state.mode === 'battle' && state.enemy) {
      ctx.fillStyle = "rgba(0,0,0,0.25)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      drawEnemySprite(state.enemy, canvas.width * 0.30, 105);
      drawPlayerFrame(getPlayerFrame(), px, py);
    }
  }

  function gameLoop() {
    draw();
    requestAnimationFrame(gameLoop);
  }

  const GACHA_COST = 500;

  const GACHA_POOL = [
    { masterId: "yuzuki",   weight: 50 },
    { masterId: "mirako",   weight: 45 },
    { masterId: "fromzero", weight: 5  }
  ];

  function rollRarity() {
    const r = Math.random();
    if (r < 0.02) return 5;
    if (r < 0.08) return 4;
    if (r < 0.23) return 3;
    if (r < 0.50) return 2;
    return 1;
  }

  function weightedPick(pool) {
    const sum = pool.reduce((a,b)=>a+b.weight,0);
    let r = Math.random() * sum;
    for (const p of pool) { r -= p.weight; if (r <= 0) return p.masterId; }
    return pool[pool.length-1].masterId;
  }

  function openGachaModal() {
    ensureSupportState();
    document.getElementById("gacha-modal").style.display = "flex";
    document.getElementById("gacha-result").innerText = "çµæœã¯ã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™";
  }
  function closeGachaModal() {
    document.getElementById("gacha-modal").style.display = "none";
  }

  function openSupportModal() {
    ensureSupportState();
    renderSupportUI();
    document.getElementById("support-modal").style.display = "flex";
  }
  function closeSupportModal() {
    document.getElementById("support-modal").style.display = "none";
  }

  function autoEquipIfEmpty(uid) {
    const s = state.supports.slots;
    if (!s.slot1) { s.slot1 = uid; return true; }
    if (!s.slot2) { s.slot2 = uid; return true; }
    if (!s.slot3) { s.slot3 = uid; return true; }
    return false;
  }

  function doGachaOnce() {
    ensureSupportState();

    if (state.money < GACHA_COST) {
      document.getElementById("gacha-result").innerText = "è³‡é‡‘ãŒè¶³ã‚Šã¾ã›ã‚“ã€‚";
      return;
    }
    state.money -= GACHA_COST;

    const masterId = weightedPick(GACHA_POOL);
    const rarity = rollRarity();

    const existing = state.supports.inventory.find(u =>
      u.masterId === masterId && u.rarity === rarity
    );

    const m = SUPPORT_MASTER[masterId];

    const rate = DUPE_RATE[rarity] ?? 0;
    const ratePct = Math.round(rate * 100);

    if (existing) {
      existing.dupes = (existing.dupes ?? 0) + 1;

      document.getElementById("gacha-result").innerHTML =
        `${rarityBadgeHTML(rarity, existing.dupes)} ${m.icon} ${m.name} ãŒãƒ€ãƒ–ã‚Šã¾ã—ãŸï¼<br>` +
        `è‡ªç„¶å¼·åŒ–ï¼šå…¨èƒ½åŠ› <b>+${ratePct}%</b>ï¼ˆç´¯è¨ˆï¼š${ratePct}% Ã— ${existing.dupes}ï¼‰`;
    } else {
      const uid = `s_${masterId}_${Date.now().toString(36)}_${Math.floor(Math.random()*999)}`;

      state.supports.inventory.push({
        uid, masterId, rarity, level: 1, exp: 0, dupes: 0
      });

      const equipped = autoEquipIfEmpty(uid);

      document.getElementById("gacha-result").innerHTML =
        `${rarityBadgeHTML(rarity, 0)} ${m.icon} ${m.name} ã‚’å…¥æ‰‹ï¼${equipped ? "ï¼ˆè‡ªå‹•è£…å‚™ï¼‰" : ""}`;
    }

    saveGame();
    updateUI();
    if (document.getElementById("support-modal").style.display === "flex") renderSupportUI();
  }

  function renderSupportUI() {
    ensureSupportState();
    const slots = state.supports.slots;

    const nameOf = (uid)=>{
      if (!uid) return "-";
      const u = getSupportUnit(uid);
      if (!u) return "-";
      const m = SUPPORT_MASTER[u.masterId];
      const dupes = u.dupes ?? 0;
      return `${rarityText(u.rarity, dupes)} ${m.icon}${m.name}`;
    };

    document.getElementById("eq1").innerText = nameOf(slots.slot1);
    document.getElementById("eq2").innerText = nameOf(slots.slot2);
    document.getElementById("eq3").innerText = nameOf(slots.slot3);

    const list = document.getElementById("support-list");
    list.innerHTML = "";

    if (!state.supports.inventory.length) {
      list.innerHTML = `<div class="text-[10px] text-gray-300 border border-white/20 bg-black/30 p-2">
        ã¾ã ã‚µãƒãƒ¼ãƒˆãŒã„ã¾ã›ã‚“ã€‚<b>ã‚¬ãƒãƒ£</b>ã§å…¥æ‰‹ã—ã¦ãã ã•ã„ã€‚
      </div>`;
      return;
    }

    for (const u of state.supports.inventory.slice().reverse()) {
      const m = SUPPORT_MASTER[u.masterId];
      if (!m) continue;

      const isEq = Object.values(slots).includes(u.uid);

      const wrap = document.createElement("div");
      wrap.className = "border border-white/20 bg-black/30 p-2";

      const dupes = u.dupes ?? 0;
      const pct = Math.round((DUPE_RATE[u.rarity] ?? 0) * 100);

      wrap.innerHTML = `
        <div class="flex justify-between items-center">
          <div class="text-xs">
            ${rarityBadgeHTML(u.rarity, dupes)} ${m.icon} <b>${m.name}</b> Lv.${u.level}
            ${isEq ? `<span class="text-green-400">ï¼ˆè£…å‚™ä¸­ï¼‰</span>` : ``}
            <div class="text-[10px] text-gray-300 mt-1">
              ã‚¹ã‚­ãƒ«ï¼š<b>${getSupportSkillDisplayName(u)}</b>
            </div>
            <div class="text-[10px] text-gray-300 mt-1">
              ãƒ€ãƒ–ã‚Šå¼·åŒ–ï¼šå…¨èƒ½åŠ› +${pct}% Ã— ${dupes}
            </div>
          </div>
        </div>
        <div class="grid grid-cols-3 gap-2 mt-2">
          <button class="btn-action" onclick="equipSupportToSlot('${u.uid}','slot1')">â‘ è£…å‚™</button>
          <button class="btn-action" onclick="equipSupportToSlot('${u.uid}','slot2')">â‘¡è£…å‚™</button>
          <button class="btn-action" onclick="equipSupportToSlot('${u.uid}','slot3')">â‘¢è£…å‚™</button>
        </div>
      `;
      list.appendChild(wrap);
    }
  }

  function equipSupportToSlot(uid, slotKey) {
    ensureSupportState();
    const u = getSupportUnit(uid);
    if (!u) return;

    state.supports.slots[slotKey] = uid;
    saveGame();
    updateUI();
    renderSupportUI();
  }

  async function init() {
    loadGame();

    await loadAllAssets();
    setupPlayerSpriteMeta();

    ensureSupportState();
    ensureCollapseState();

    applyOfflineProgress();
    enableAutoSave();

    ensureDefaultBagOwned();
    updateLootMaxFromBag();
    applyTownGrowth();

    setInterval(mainLoopTick, 1000);
    gameLoop();

    showTab(state.uiTab || 'town');

    updateUI();
    refreshShop();
  }

  window.onload = init;
</script>

</body>
</html>