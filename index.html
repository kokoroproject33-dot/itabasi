<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Eco-Town Legend EX - Mobile Base</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
  @import url('https://fonts.googleapis.com/css2?family=DotGothic16&display=swap');

  :root {
    --primary-bg: #050505;
    --panel-bg: rgba(20, 20, 20, 0.9);
    --border-color: #ffffff;
  }

 
/* âœ… å›½æ°‘ç·æ”¯æ´ï¼šä½¿ç”¨å¯èƒ½ã‚µã‚¤ãƒ³ï¼ˆã†ã£ã™ã‚‰ç‚¹æ»…ï¼‰ */
@keyframes softPulse {
  0%   { opacity: 0.55; filter: brightness(0.85); }
  50%  { opacity: 1.00; filter: brightness(1.15); }
  100% { opacity: 0.55; filter: brightness(0.85); }
}


.pulse-available {
  animation: softPulse 1.2s ease-in-out infinite;
  box-shadow: 0 0 10px rgba(255,255,255,0.12);
}
    body {
      background-color: var(--primary-bg);
      color: #fff;
      font-family: 'DotGothic16', sans-serif;
      margin: 0;
      overflow: hidden;
      touch-action: manipulation;
    }

    /* âœ… iPhone Safariã®ä¸‹ãƒãƒ¼å¯¾ç­–ï¼šsafe-areaä¸‹ä½™ç™½ */
    .safe-bottom {
      padding-bottom: env(safe-area-inset-bottom);
    }

    .app-container {
      width: 100vw;
      /* âœ… 100vhã¯iPhone Safariã§ã‚ºãƒ¬ã‚‹ã®ã§innerHeightå®Ÿæ¸¬ã«ã™ã‚‹ */
      height: var(--app-h, 100vh);
      display: flex;
      flex-direction: column;
      max-width: 500px;
      margin: 0 auto;
      border-left: 1px solid #333;
      border-right: 1px solid #333;
    }

    .btn-action {
      background: #222;
      border: 2px solid var(--border-color);
      padding: 12px 8px;
      text-align: center;
      font-size: 14px;
      cursor: pointer;
      transition: transform 0.1s, background 0.1s;
    }
    .btn-action:active:not(.disabled) {
      transform: scale(0.95);
      background: #fff;
      color: #000;
    }
    .disabled {
      opacity: 0.3;
      pointer-events: none;
      filter: grayscale(1);
    }

    .stat-bar {
      height: 12px;
      background: #111;
      border: 1px solid #444;
      border-radius: 6px;
      overflow: hidden;
    }

    #game-canvas {
      image-rendering: pixelated;
      width: 100%;
      background: #0a0a0a;
      flex-shrink: 0;
      display: block;
    }

    .ad-placeholder {
      background: #1a1a1a;
      color: #444;
      height: 50px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      border-top: 1px solid #333;
    }

    .floating-text {
      position: absolute;
      animation: floatUp 1.2s ease-out forwards;
      pointer-events: none;
      font-weight: bold;
      font-size: 16px;
      z-index: 100;
      text-shadow: 2px 2px #000;
    }
    @keyframes floatUp {
      0% { transform: translateY(0); opacity: 1; }
      100% { transform: translateY(-60px); opacity: 0; }
    }

    .tab-content { display: none; height: 100%; overflow-y: auto; }
    .tab-content.active { display: block; }

    #custom-modal {
      display: none;
      position: absolute;
      inset: 0;
      background: rgba(0,0,0,0.8);
      z-index: 1000;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    .hint-banner {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      bottom: 8px;
      background: rgba(0,0,0,0.75);
      border: 1px solid rgba(255,255,255,0.35);
      padding: 6px 10px;
      font-size: 10px;
      z-index: 30;
      pointer-events: none;
      white-space: nowrap;
    }

    .asset-status {
      position: absolute;
      top: 8px;
      right: 8px;
      background: rgba(0,0,0,0.70);
      border: 1px solid rgba(255,255,255,0.35);
      padding: 4px 6px;
      font-size: 9px;
      z-index: 25;
      pointer-events: none;
      line-height: 1.25;
      text-align: right;
      white-space: nowrap;
    }

    /* æ¿æ©‹ã‚¤ãƒ™ãƒ³ãƒˆã®ã‚­ãƒ£ãƒ©ç”»åƒãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ */
    #itabashi-portrait {
      animation: itbFadeIn 0.4s ease-out forwards;
    }
    @keyframes itbFadeIn {
      from { opacity: 0; transform: translateY(6px); }
      to   { opacity: 0.95; transform: translateY(0); }
    }
  </style>
</head>

<body>
  <div class="app-container">
    <!-- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒãƒ¼ -->
    <div class="grid grid-cols-3 gap-1 p-2 bg-black border-b-2 border-white text-[10px]">
      <div class="text-center">
        <div class="text-gray-400">è³‡é‡‘</div>
        <div class="text-yellow-400 font-bold text-sm"><span id="ui-money">0</span> G</div>
      </div>
      <div class="text-center border-x border-gray-800">
        <div class="text-gray-400">äººå£</div>
        <div class="text-white font-bold text-sm" id="ui-pop">100</div>
      </div>
      <div class="text-center">
        <div class="text-gray-400">ã‚´ãƒŸ</div>
        <div class="text-red-400 font-bold text-sm" id="ui-waste">0.0</div>
      </div>
    </div>

    <!-- ãƒ¡ã‚¤ãƒ³ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ«ï¼ˆCanvasï¼‰ -->
    <div class="relative overflow-hidden bg-black" id="screen-container">
      <canvas id="game-canvas"></canvas>

      <!-- âœ… ä¸–ç•Œå´©å£Šãƒ•ã‚§ãƒ¼ã‚ºãƒ»ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ï¼ˆã‚­ãƒ£ãƒ³ã‚»ãƒ«ä¸å¯æ¼”å‡ºï¼‰ -->
      <div id="collapse-overlay" style="display:none; position:absolute; inset:0; z-index:2000; background:rgba(0,0,0,0.92); align-items:center; justify-content:center; padding:18px;">
        <div class="bg-black/80 border-2 border-red-500 p-4 w-full max-w-sm text-center space-y-3">
          <div class="text-red-400 font-bold text-sm">âš  ä¸–ç•Œå´©å£Šãƒ•ã‚§ãƒ¼ã‚º</div>
          <div id="collapse-text" class="text-[11px] text-gray-200 leading-relaxed">
            å´©å£ŠãŒå§‹ã¾ã‚Šã¾ã—ãŸã€‚<br>
            ç’°å¢ƒãƒ»æ²»å®‰ãƒ»å¥åº·ãŒæ€¥æ¿€ã«æ‚ªåŒ–ã—ã¾ã™ã€‚<br>
            ç«‹ã¦ç›´ã›ã‚‹ã‹ã©ã†ã‹ã€ä»Šã“ã“ã‹ã‚‰ã§ã™ã€‚
          </div>
          <div class="text-[10px] text-gray-400">
            â€»ã“ã®è­¦å‘Šã¯é–‰ã˜ã‚‰ã‚Œã¾ã›ã‚“ï¼ˆçªå…¥æ¼”å‡ºï¼‰
          </div>
        </div>
      </div>

      <!-- âœ… åˆå›å°å…¥ã‚¤ãƒ™ãƒ³ãƒˆç”¨ã®ãƒ¢ãƒ¼ãƒ€ãƒ«ã€‚åˆã‚ã¦ã‚²ãƒ¼ãƒ ã‚’èµ·å‹•ã—ãŸã¨ãã ã‘è¡¨ç¤ºã•ã‚Œã¾ã™ -->
      <div id="intro-modal" style="display:none; position:fixed; inset:0; z-index:3000; background:rgba(0,0,0,0.88); flex-direction:column; align-items:center; justify-content:center; padding:20px;">
        <div class="flex flex-col items-center w-full max-w-sm space-y-3">
          <!-- æ¡ˆå†…å½¹ã‚­ãƒ£ãƒ©ç”»åƒ -->
          <!-- ã‚¬ã‚¤ãƒ‰ç”»åƒï¼šItabashi(ã‚³ã‚³ãƒ­)ã®ç”»åƒã‚’ã‚¤ãƒ³ã‚²ãƒ¼ãƒ ã«ä½¿ç”¨ã—ã¾ã™ã€‚ç”»åƒã¯HTMLã¨åŒã˜éšå±¤ã«é…ç½®ã—ã¦ãã ã•ã„ -->
          <img src="itabashi.png" alt="æ¡ˆå†…å½¹" class="w-full rounded" style="object-fit:cover;">
          <!-- ã‚»ãƒªãƒ•è¡¨ç¤ºã‚¨ãƒªã‚¢ -->
          <div id="intro-text" class="text-[12px] leading-relaxed text-gray-200 whitespace-pre-line text-center"></div>
          <div class="text-[10px] text-gray-500 italic">ã‚¿ãƒƒãƒ—ã§é€²ã‚€</div>
        </div>
      </div>

      <!-- âœ… èµ¤å¡šå…¬åœ’ã‚¯ãƒªã‚¢å¾Œã‚¤ãƒ™ãƒ³ãƒˆç”¨ãƒ¢ãƒ¼ãƒ€ãƒ«ï¼ˆæ¿æ©‹ã‚¤ãƒ™ãƒ³ãƒˆï¼‰ -->
      <div id="itabashi-modal" style="display:none; position:fixed; inset:0; z-index:3000; background:rgba(0,0,0,0.88); flex-direction:column; align-items:center; justify-content:center; padding:20px;">
        <div class="flex flex-col items-center w-full max-w-sm space-y-3">
          <!-- æ¿æ©‹ã‚¤ãƒ™ãƒ³ãƒˆç”¨ï¼šã‚­ãƒ£ãƒ©ç”»åƒã‚’è¡¨ç¤º -->
          <img id="itabashi-portrait" src="itabashi.png" alt="æ¿æ©‹" class="w-32 h-auto rounded-lg shadow-lg opacity-95" />
          <!-- æ¿æ©‹ã‚¤ãƒ™ãƒ³ãƒˆã®ã‚»ãƒªãƒ•è¡¨ç¤ºã‚¨ãƒªã‚¢ -->
          <div id="itabashi-text" class="text-[12px] leading-relaxed text-gray-200 whitespace-pre-line text-center"></div>
          <!-- ã‚¯ãƒªãƒƒã‚¯ã‚’ä¿ƒã™ãƒ†ã‚­ã‚¹ãƒˆ -->
          <div id="itabashi-tap" class="text-[10px] text-gray-500 italic">ã‚¿ãƒƒãƒ—ã§é€²ã‚€</div>
          <!-- é¸æŠè‚¢ãƒœã‚¿ãƒ³ã‚¨ãƒªã‚¢ï¼ˆæœ€å¾Œã«è¡¨ç¤ºï¼‰ -->
          <div id="itabashi-choices" class="w-full space-y-2 hidden">
            <button id="itabashi-choice-1" class="btn-action w-full"></button>
            <button id="itabashi-choice-2" class="btn-action w-full"></button>
          </div>
        </div>
      </div>

      <!-- 4ã‚¹ãƒ† -->
      <div class="absolute top-2 left-2 bg-black/70 p-1 border border-white/50 text-[9px] z-20">
        ATK:<span id="st-atk">0</span>
        DEF:<span id="st-def">0</span>
        SPD:<span id="st-spd">0</span>
        LUK:<span id="st-luk">0</span>
      </div>

      <div class="asset-status" id="asset-status">ASSET: ...</div>

      <div id="place-hint" class="hint-banner hidden">
        æ–½è¨­ã‚’ç½®ãå ´æ‰€ã‚’ã‚¿ãƒƒãƒ—ï¼ˆé“è·¯ã«ã¯ç½®ã‘ã¾ã›ã‚“ï¼‰
      </div>
    </div>

    <!-- ãƒãƒˆãƒ«HUD -->
    <div id="battle-hud" class="hidden bg-black/90 border-t border-white/20 p-2 space-y-2">
      <div class="border-2 border-red-500 p-2 bg-black/80">
        <div id="enemy-name" class="text-xs text-red-500 font-bold mb-1 text-center">MONSTER</div>
        <div class="stat-bar">
          <div id="enemy-hp-bar" class="bg-red-600 h-full w-full transition-all duration-300"></div>
        </div>
        <div id="enemy-hp-text" class="text-[10px] text-white mt-1 text-center">0/0</div>
      </div>

      <div class="border-2 border-blue-500 p-2 bg-black/80">
        <div class="text-[10px] text-blue-400 font-bold mb-1 text-center">PLAYER HP</div>
        <div class="stat-bar">
          <div id="battle-player-hp-bar" class="bg-green-500 h-full w-full transition-all duration-300"></div>
        </div>
        <div id="battle-player-hp-text" class="text-[10px] text-white mt-1 text-center">100/100</div>
      </div>
    </div>

    <!-- ãƒ­ã‚° -->
    <div id="msg-layer" class="w-full bg-black/80 p-2 text-[11px] border-t border-white/30 h-12 flex items-center">
      <div id="game-log">é å¾ã®æº–å‚™ã‚’ã—ã¾ã—ã‚‡ã†ã€‚</div>
    </div>

    <!-- ç’°å¢ƒã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ -->
    <div class="p-2 bg-gray-900 grid grid-cols-3 gap-2 text-[9px] border-b border-white/20">
      <div>
        ğŸŒ ç’°å¢ƒ <span id="val-env">80</span>%
        <div class="stat-bar"><div id="bar-env" class="bg-green-500 h-full"></div></div>
      </div>
      <div>
        âš–ï¸ æ²»å®‰ <span id="val-sec">80</span>%
        <div class="stat-bar"><div id="bar-sec" class="bg-blue-500 h-full"></div></div>
      </div>
      <div>
        ğŸ’Š å¥åº· <span id="val-heal">80</span>%
        <div class="stat-bar"><div id="bar-heal" class="bg-red-500 h-full"></div></div>
      </div>
    </div>

    <!-- ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ -->
    <div class="flex-grow bg-black p-3 relative overflow-hidden">
      <!-- è¡— -->
      <div id="tab-town" class="tab-content active space-y-3">
        <div class="text-[11px] text-gray-200 border border-white/20 p-2">
  ğŸ¤ ä¿¡é ¼ <span id="val-trust">0</span>%
  <div class="stat-bar mt-1">
    <div id="bar-trust" class="bg-yellow-400 h-full"></div>
  </div>
  <div class="text-[9px] text-gray-400 mt-1">
    å¸‚æ°‘ãƒ»æ”¯æ´è€…ã‹ã‚‰ã®ä¿¡é ¼
  </div>
</div>
        <button onclick="buyUpgrade('park')" class="btn-action w-full flex justify-between items-center">
          <span>â›² å…¬åœ’æ•´å‚™ï¼ˆç’°å¢ƒ+ï¼‰</span><span class="text-yellow-400">1,000G</span>
        </button>
        <button onclick="startPatrol()" class="btn-action w-full flex justify-between items-center">
          <span>ğŸš¶ ãƒ‘ãƒˆãƒ­ãƒ¼ãƒ«ï¼ˆæ²»å®‰+ / ä¸€å®šæ™‚é–“ãƒ–ãƒ¼ã‚¹ãƒˆï¼‰</span>
          <span class="text-yellow-400" id="patrol-cost">400G</span>
        </button>
        <button onclick="buyUpgrade('medical')" class="btn-action w-full flex justify-between items-center">
          <span>ğŸ’Š åŒ»ç™‚æŠ•è³‡ï¼ˆå¥åº·+ï¼‰</span><span class="text-yellow-400">2,500G</span>
        </button>

        <button onclick="selectFacilityToPlace('hospital')" class="btn-action w-full flex justify-between items-center">
          <span>ğŸ¥ ç—…é™¢ è¨­ç½®ï¼ˆæœ€å¤§5ï¼‰</span><span class="text-yellow-400">2,500G</span>
        </button>
        <button onclick="selectFacilityToPlace('police')" class="btn-action w-full flex justify-between items-center">
          <span>ğŸš“ è­¦å¯Ÿç½² è¨­ç½®</span><span class="text-yellow-400">6,000G</span>
        </button>
        <button onclick="selectFacilityToPlace('fire')" class="btn-action w-full flex justify-between items-center">
          <span>ğŸš’ æ¶ˆé˜²ç½² è¨­ç½®</span><span class="text-yellow-400">6,000G</span>
        </button>
        <button onclick="recruitStaff()" class="btn-action w-full flex flex-col items-start gap-1">
  <div class="flex justify-between w-full">
    <span>ğŸ§¹ æ¸…æƒå“¡é›‡ç”¨</span>
    <span class="text-yellow-400" id="staff-cost">300G</span>
  </div>
  <div class="text-[9px] text-gray-300">
    æ¸…æƒå“¡ <span id="ui-staff">0</span> äºº ï½œ æ¸…æƒåŠ› <span id="ui-clean">0.0</span> / ç§’
  </div>
</button>
        <div class="text-[10px] text-gray-300 border border-white/10 p-2">
          âœ… æ–½è¨­ã¯ã€Œå¥½ããªä½ç½®ã€ã«ç½®ã‘ã¾ã™ï¼ˆ<b>é“è·¯ã«ã¯ä¸å¯</b>ï¼‰ã€‚<br/>
          âœ… æ—¢ã«å»ºç‰©ãŒã‚ã‚‹å ´æ‰€ã«ç½®ãã¨ã€ãã®å»ºç‰©ã¯æ¶ˆãˆã€äººå£ãŒæ¸›ã‚Šã¾ã™ï¼ˆä¾‹ï¼šãƒ“ãƒ«ãªã‚‰ -50ï¼‰ã€‚<br/>
          âœ… åŠ¹æœï¼šè­¦å¯Ÿç½²=ç›—é›£/æ”¾ç«ã®æŠ‘æ­¢ã€æ¶ˆé˜²ç½²=æ”¾ç«ã®é®ç«åˆ¤å®šã€ç—…é™¢=æ„ŸæŸ“æ‹¡å¤§ã®æŠ‘æ­¢ã€‚
        </div>
      </div>

      <!-- è£…å‚™/åº— -->
      <div id="tab-shop" class="tab-content space-y-2">
        <div class="text-[10px] border border-white/20 p-2 text-gray-200 bg-black/30">
          ğŸ§° ã‚´ãƒŸè¢‹ç³»ã¯ã€Œè³¼å…¥ â†’ ã‚¿ãƒƒãƒ—ã€ã§è£…å‚™ã§ãã¾ã™ï¼ˆå›åä¸Šé™ãŒå¤‰åŒ–ï¼‰ã€‚<br>
          â€»è£…å‚™/è§£é™¤ã§åŠ¹æœãŒåæ˜ ã•ã‚Œã¾ã™ï¼ˆè³¼å…¥ã—ãŸã ã‘ã§ã¯åæ˜ ã•ã‚Œã¾ã›ã‚“ï¼‰ã€‚
        </div>

        <div class="text-[10px] border border-white/20 p-2 bg-black/30 space-y-2">
          <div class="font-bold text-xs text-center">ğŸ§° è£…å‚™æ¬„</div>
          <div class="grid grid-cols-3 gap-2">
            <div class="border border-white/20 p-2 text-center">
              <div class="text-gray-300">æ­¦å™¨</div>
              <div id="eq-weapon" class="font-bold">-</div>
            </div>
            <div class="border border-white/20 p-2 text-center">
              <div class="text-gray-300">æ‰‹</div>
              <div id="eq-hand" class="font-bold">-</div>
            </div>
            <div class="border border-white/20 p-2 text-center">
              <div class="text-gray-300">èƒ´</div>
              <div id="eq-body" class="font-bold">-</div>
            </div>
          </div>
          <div class="text-[9px] text-gray-300">
            â€»ã€Œè£…å‚™/è§£é™¤ã€ã§åŠ¹æœãŒåæ˜ ã•ã‚Œã¾ã™ï¼ˆè³¼å…¥ã—ãŸã ã‘ã§ã¯åæ˜ ã•ã‚Œã¾ã›ã‚“ï¼‰ã€‚
          </div>
        </div>

        <button onclick="openGachaModal()" class="btn-action w-full flex justify-between items-center">
          <span>ğŸ° ã‚µãƒãƒ¼ãƒˆã‚¬ãƒãƒ£ï¼ˆ1å›ï¼‰</span><span class="text-yellow-400">500G</span>
        </button>
        <button onclick="openSupportModal()" class="btn-action w-full flex justify-between items-center">
          <span>ğŸ§‘â€ğŸ¤â€ğŸ§‘ ã‚µãƒãƒ¼ãƒˆä¸€è¦§ / è£…å‚™</span><span class="text-gray-400">ç®¡ç†</span>
        </button>

        <div id="shop-items" class="space-y-2 pb-4"></div>
      </div>

      <!-- é å¾ -->
      <div id="tab-explore" class="tab-content">
        <div id="dungeon-select" class="space-y-2 mb-3">
          <!-- å„é å¾å…ˆãƒœã‚¿ãƒ³ã«IDã‚’ä»˜ä¸ã—ã¦å¾Œã§çŠ¶æ…‹ã‚’æ“ä½œã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ -->
          <button id="btn-dungeon-akatsuka" onclick="selectDungeon('akatsuka')" class="btn-action w-full">ğŸŒ³ èµ¤å¡šå…¬åœ’ï¼ˆåˆç´šï¼‰</button>
          <button id="btn-dungeon-takashimadaira" onclick="selectDungeon('takashimadaira')" class="btn-action w-full">ğŸ™ï¸ é«˜å³¶å¹³ï¼ˆä¸­ç´šï¼‰</button>
          <button id="btn-dungeon-arakawa" onclick="selectDungeon('arakawa')" class="btn-action w-full">ğŸŒŠ è’å·ï¼ˆä¸Šç´šï¼‰</button>
          <button id="btn-dungeon-national" onclick="selectDungeon('national')" class="btn-action w-full bg-yellow-700">ğŸŒ å…¨å›½ä¸€æ–‰ï¼ˆæœ€çµ‚ï¼‰</button>
        </div>
        <div id="ui-town-ctrl" class="space-y-3">
          <div class="flex justify-between text-xs">
            <span>Lv.<span id="ui-lv">1</span> HP:<span id="ui-hp-text">100/100</span></span>
            <span>NEXT:<span id="ui-xp">50</span></span>
          </div>
          <div class="stat-bar"><div id="hp-bar" class="bg-green-500 h-full w-full"></div></div>

          <button onclick="startDungeon()" class="btn-action w-full bg-red-900 py-6 text-lg font-bold">
            â–¶ å»ƒæ£„ç‰©ã‚¨ãƒªã‚¢ã¸é å¾ï¼ˆã‚²ãƒ¼ãƒ é–‹å§‹ï¼‰
          </button>

          <div class="text-[10px] text-gray-300 border border-white/10 p-2">
            â€»é å¾ä¸­ã¯ã€Œè¡—ã¥ãã‚Š/è£…å‚™ã€ã¯é–‹ã‘ã¾ã›ã‚“ã€‚æ’¤é€€ã—ã¦æˆ»ã£ã¦ãã ã•ã„ã€‚
          </div>
        </div>

        <div id="loot-panel" class="mt-3 space-y-1">
          <div class="mt-1 text-[10px] flex justify-between">
            <span>ğŸ—‘ï¸ å›åï¼ˆã‚´ãƒŸè¢‹ï¼‰</span>
            <span><span id="ui-loot">0</span> / <span id="ui-loot-max">100</span></span>
          </div>
          <div class="stat-bar">
            <div id="loot-bar" class="bg-yellow-400 h-full w-0 transition-all duration-300"></div>
          </div>
          <div class="text-[9px] text-gray-300 mt-1">
            è£…å‚™ï¼š<span id="ui-bag-name">-</span>
          </div>
        </div>

        <div id="ui-dungeon-ctrl" class="mt-3 hidden grid grid-cols-2 gap-2">
          <button onclick="dungeonStep()" class="btn-action col-span-2 bg-blue-900 py-8 text-xl">ğŸš¶ æ¢ç´¢(å‰é€²)</button>
          <button onclick="useDrink()" id="btn-drink" class="btn-action">ğŸ§ª ãƒœãƒˆãƒ«(0)</button>
          <button onclick="returnTown()" class="btn-action bg-gray-800">ğŸ  æ’¤é€€</button>
        </div>

        <div id="ui-battle-ctrl" class="mt-3 hidden grid grid-cols-2 gap-2">
          <button id="btn-atk" onclick="battleTurn('attack')" class="btn-action bg-red-600 py-4 font-bold">âš”ï¸ æ”»æ’ƒ</button>
          <!-- ã‚¹ã‚­ãƒ«ãƒœã‚¿ãƒ³ï¼šé˜²å¾¡ãƒœã‚¿ãƒ³ã‚’ç½®ãæ›ãˆ -->
          <button id="btn-skill" class="btn-action bg-purple-600 py-4 font-bold">âœ¨ ã‚¹ã‚­ãƒ«</button>
          <button id="btn-heal" onclick="battleTurn('heal')" class="btn-action bg-green-600 py-4 font-bold">ğŸ§ª å›å¾©</button>
          <button id="btn-flee" onclick="battleTurn('flee')" class="btn-action bg-gray-600 py-4 font-bold">ğŸƒ é€ƒèµ°</button>
        </div>
      </div>
    </div>

    <!-- âœ… ãƒŠãƒ“ï¼ˆsafe-areaå¯¾å¿œã§ã‚¿ãƒ–ãŒæ²ˆã¾ãªã„ï¼‰ -->
    <div class="grid grid-cols-3 bg-white text-black font-bold text-xs shadow-[0_-4px_10px_rgba(0,0,0,0.5)] safe-bottom">
      <button id="nav-town" onclick="showTab('town')" class="py-4 border-r border-gray-300 active:bg-gray-200">è¡—ã¥ãã‚Š</button>
      <button id="nav-shop" onclick="showTab('shop')" class="py-4 border-r border-gray-300 active:bg-gray-200">è£…å‚™/åº—</button>
      <button id="nav-explore" onclick="showTab('explore')" class="py-4 active:bg-gray-200">é å¾</button>
    </div>

    <!-- âœ… åºƒå‘Šæ ã‚‚safe-areaå¯¾å¿œï¼ˆä»»æ„ã ã‘ã©å®‰å®šï¼‰ -->
    <div id="btn-national-support" class="ad-placeholder safe-bottom" onclick="useNationalSupport()">
  ğŸ› å›½æ°‘ç·æ”¯æ´ï¼ˆå´©å£Šãƒ•ã‚§ãƒ¼ã‚ºä¸­ã®ã¿ï¼‰
</div>
  <div id="custom-modal">
    <div class="bg-gray-900 border-2 border-white p-6 w-full max-w-xs text-center">
      <div id="modal-text" class="mb-6 text-sm"></div>
      <button onclick="closeModal()" class="btn-action w-full">OK</button>
    </div>
  </div>

  <!-- ã‚¬ãƒãƒ£ãƒ¢ãƒ¼ãƒ€ãƒ« -->
  <div id="gacha-modal" style="display:none; position:absolute; inset:0; background:rgba(0,0,0,0.85); z-index:1200; align-items:center; justify-content:center; padding:18px;">
    <div class="bg-gray-900 border-2 border-white p-4 w-full max-w-sm text-center space-y-3">
      <div class="text-sm font-bold">ğŸ° ã‚µãƒãƒ¼ãƒˆã‚¬ãƒãƒ£</div>
      <div class="text-[10px] text-gray-300">500Gã§1å›ã€‚ã‚µãƒãƒ¼ãƒˆãŒå¢—ãˆã‚‹ã»ã©ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãŒä¼¸ã³ã¾ã™ã€‚</div>
      <div id="gacha-result" class="text-sm py-3 border border-white/20 bg-black/40">çµæœã¯ã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™</div>
      <div class="grid grid-cols-2 gap-2">
        <button onclick="doGachaOnce()" class="btn-action">1å›å¼•ã</button>
        <button onclick="closeGachaModal()" class="btn-action">é–‰ã˜ã‚‹</button>
      </div>
    </div>
  </div>

  <!-- ã‚µãƒãƒ¼ãƒˆç®¡ç†ãƒ¢ãƒ¼ãƒ€ãƒ« -->
  <div id="support-modal" style="display:none; position:absolute; inset:0; background:rgba(0,0,0,0.85); z-index:1200; align-items:center; justify-content:center; padding:18px;">
    <div class="bg-gray-900 border-2 border-white p-4 w-full max-w-sm text-left space-y-3">
      <div class="text-center text-sm font-bold">ğŸ§‘â€ğŸ¤â€ğŸ§‘ ã‚µãƒãƒ¼ãƒˆç®¡ç†</div>
      <div class="text-[10px] text-gray-300">æ‰€æŒä¸€è¦§ã‹ã‚‰ã‚¹ãƒ­ãƒƒãƒˆ1ã€œ3ã«è£…å‚™ã§ãã¾ã™ã€‚</div>

      <div class="text-[10px] border border-white/20 p-2 bg-black/30">
        è£…å‚™ä¸­ï¼šâ‘  <span id="eq1">-</span> ï¼ â‘¡ <span id="eq2">-</span> ï¼ â‘¢ <span id="eq3">-</span>
      </div>

      <div id="support-list" class="space-y-2 max-h-[45vh] overflow-y-auto"></div>

      <button onclick="closeSupportModal()" class="btn-action w-full">é–‰ã˜ã‚‹</button>
    </div>
  </div>

  <!-- ã‚¹ã‚­ãƒ«é¸æŠãƒ¢ãƒ¼ãƒ€ãƒ« -->
  <div id="skill-modal" class="hidden fixed inset-0 bg-black/70 flex items-center justify-center z-[2000]">
    <div class="bg-gray-900 border p-4 w-72">
      <h3 class="text-center mb-2">ã‚¹ã‚­ãƒ«é¸æŠ</h3>
      <!-- å„ã‚¹ã‚­ãƒ«ãƒœã‚¿ãƒ³ã«ã¯ data-skill å±æ€§ã§ã‚­ãƒ¼ã‚’æŒ‡å®š -->
      <button class="skill-item w-full border mb-2 p-2" data-skill="heal">
        ğŸŒ± å›å¾©ï¼ˆHP+30ï¼‰
      </button>
      <button class="skill-item w-full border mb-2 p-2" data-skill="power">
        ğŸ’¥ å¼·æ‰“ï¼ˆæ”»æ’ƒÃ—1.5ï¼‰
      </button>
      <!-- æ–°ã‚¹ã‚­ãƒ«ï¼šè«¦ã‚ãªã„æ„æ€ï¼ˆé«˜å³¶å¹³ã‚¯ãƒªã‚¢å¾Œã«è§£æ”¾ï¼‰ -->
      <button id="skill-unwavering" class="skill-item w-full border mb-2 p-2 hidden" data-skill="unwavering">
        ğŸ’ª è«¦ã‚ãªã„æ„æ€ï¼ˆæ¯ã‚¿ãƒ¼ãƒ³HP+50 Ã—3ã‚¿ãƒ¼ãƒ³ï¼‰
      </button>
      <button id="skill-cancel" class="w-full border p-2">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
    </div>
  </div>
</div> <!-- â† app-container ã‚’é–‰ã˜ã‚‹ -->
<script>
  /* =========================================================
     âœ… iPhone Safariã®100vhã‚ºãƒ¬å¯¾ç­–ï¼šå®Ÿæ¸¬ã®é«˜ã•ã‚’CSSå¤‰æ•°ã¸
     ========================================================= */
  function setAppHeightVar() {
    document.documentElement.style.setProperty('--app-h', `${window.innerHeight}px`);
  }
  window.addEventListener('resize', setAppHeightVar);
  window.addEventListener('orientationchange', setAppHeightVar);
  setAppHeightVar();

  // =========================================================
  // 4ã‚¹ãƒ†å¯¾å¿œï¼ˆATK/DEF/SPD/LUKï¼‰
  // =========================================================

  const MONEY_PER_LOOT = 5;
  const CITY_WASTE_REDUCTION_PER_LOOT = 0.03;

  const ENEMY_WASTE_SCALE_MAX = 15;
  const ENEMY_HP_BOOST_MAX = 1.2;
  const ENEMY_ATK_BOOST_MAX = 0.6;

  const BOSS_DISTANCE_M = 200;
  const STEP_M = 10;
  const BOSS_DISTANCE_STEP = Math.floor(BOSS_DISTANCE_M / STEP_M);
  const BOSS_WASTE_REDUCE_RATE = 0.30;

  const BOSS = {
  n: "èµ¤å¡šå…¬åœ’ã®ä¸æ³•æŠ•æ£„ã‚­ãƒ³ã‚°", // å¥½ããªåå‰ã«å¤‰æ›´OK
  h: 900,
  a: 65,
  s: 12,
  x: 900,
  e: "ğŸ‘‘",          // ç”»åƒãŒè¡¨ç¤ºã•ã‚Œãªã„æ™‚ã®ä¿é™ºï¼ˆä»»æ„ï¼‰
  imgKey: "enemy3", // âœ… ã“ã®ç”»åƒã«ã™ã‚‹ã‚­ãƒ¼
  hpWeight: 0.8,
  atkWeight: 0.7
};

  // ================================
  // ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³å®šç¾©
  // å„ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³ã”ã¨ã«ãƒœã‚¹ã‚„åç§°ã‚’ç®¡ç†ã—ã¾ã™
  const DUNGEONS = {
    akatsuka: {
      id: "akatsuka",
      name: "èµ¤å¡šå…¬åœ’",
      desc: "ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ã‚¨ãƒªã‚¢",
      boss: {
        n: "èµ¤å¡šå…¬åœ’ã®ä¸æ³•æŠ•æ£„ã‚­ãƒ³ã‚°",
        h: 900,
        a: 65,
        s: 12,
        x: 900,
        e: "ğŸ‘‘",
        imgKey: "enemy3",
        hpWeight: 0.8,
        atkWeight: 0.7
      }
    },
    takashimadaira: {
      id: "takashimadaira",
      name: "é«˜å³¶å¹³",
      desc: "ä½å®…åœ°ã«æ½œã‚€ã‚´ãƒŸå•é¡Œ",
      boss: {
        // âœ… èµ¤å¡šå…¬åœ’ãƒœã‚¹ã®1.5å€ç›¸å½“ã§èª¿æ•´
        n: "æ¶ˆã—å¿˜ã‚Œãƒã‚¤æ¨ã¦ã‚¿ãƒã‚³",
        h: 1350,
        a: 98,
        s: 14,
        x: 1350,
        e: "ğŸš¬",
        imgKey: "enemy2",
        hpWeight: 1.0,
        atkWeight: 0.9
      }
    },
    arakawa: {
      id: "arakawa",
      name: "è’å·",
      desc: "å¤§é‡æ¼‚ç€ã‚¨ãƒªã‚¢",
      boss: {
        n: "è’å·ãƒ»æ¼‚ç€ã‚´ãƒŸã®åŒ–èº«",
        h: 2600,
        a: 130,
        s: 20,
        x: 2600,
        e: "ğŸŒŠ",
        imgKey: "enemy1",
        hpWeight: 1.2,
        atkWeight: 1.1
      }
    },
    national: {
      id: "national",
      name: "å…¨å›½ä¸€æ–‰",
      desc: "æœ€çµ‚ã‚¹ãƒ†ãƒ¼ã‚¸",
      boss: {
        n: "æ–‡æ˜ã®è² å‚µ",
        h: 5000,
        a: 180,
        s: 28,
        x: 5000,
        e: "ğŸŒ",
        imgKey: "enemy3",
        hpWeight: 1.5,
        atkWeight: 1.4
      }
    }
  };

  // =========================================================
  // âœ… ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³è§£æ”¾åˆ¤å®šã¨ãƒœã‚¿ãƒ³è¡¨ç¤ºæ›´æ–°ãƒ­ã‚¸ãƒƒã‚¯
  // =========================================================
  /**
   * æŒ‡å®šã—ãŸãƒ€ãƒ³ã‚¸ãƒ§ãƒ³IDãŒè§£æ”¾ã•ã‚Œã¦ã„ã‚‹ã‹åˆ¤å®šã—ã¾ã™ã€‚
   * - akatsuka ã¯å¸¸ã«è§£æ”¾
   * - takashimadaira ã¯ akatsuka ã‚¯ãƒªã‚¢å¾Œã«è§£æ”¾
   * - arakawa ã¯ takashimadaira ã‚¯ãƒªã‚¢å¾Œã«è§£æ”¾
   * - national ã¯å…¨ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³ã‚’ã‚¯ãƒªã‚¢ã—ã€è»¢ç”Ÿå›æ•°ãŒ1å›ä»¥ä¸Šã®æ™‚ã«è§£æ”¾
   * @param {string} id ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³ID
   * @returns {boolean} è§£æ”¾ã•ã‚Œã¦ã„ã‚Œã° true
   */
  function isDungeonUnlocked(id) {
    // èµ¤å¡šå…¬åœ’ã¯å¸¸ã«è§£æ”¾
    if (id === 'akatsuka') return true;
    // é«˜å³¶å¹³ã¯èµ¤å¡šå…¬åœ’ã‚¯ãƒªã‚¢å¾Œ
    if (id === 'takashimadaira') return state?.cleared?.akatsuka;
    // è’å·ã¯é«˜å³¶å¹³ã‚¯ãƒªã‚¢å¾Œ
    if (id === 'arakawa') return state?.cleared?.takashimadaira;
    // æœ€çµ‚ã‚¹ãƒ†ãƒ¼ã‚¸ã¯å…¨ã¦ã®ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³ã‚’ã‚¯ãƒªã‚¢ã‹ã¤è»¢ç”Ÿ1å›ä»¥ä¸Š
    if (id === 'national') {
      return (state?.reincarnations ?? 0) >= 1 &&
             state?.cleared?.akatsuka &&
             state?.cleared?.takashimadaira &&
             state?.cleared?.arakawa;
    }
    return false;
  }

  /**
   * ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³ã‚»ãƒ¬ã‚¯ãƒˆç”»é¢ã®ãƒœã‚¿ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã¨çŠ¶æ…‹ã‚’æ›´æ–°ã—ã¾ã™ã€‚
   * è§£æ”¾ã•ã‚Œã¦ã„ãªã„ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³ã¯ã€Œï¼Ÿï¼Ÿï¼Ÿã€ã¨è¡¨ç¤ºã—ã€disabled ã‚¯ãƒ©ã‚¹ã‚’ä»˜ã‘ã¾ã™ã€‚
   */
  function updateDungeonButtons() {
    const btnAk = document.getElementById('btn-dungeon-akatsuka');
    const btnTa = document.getElementById('btn-dungeon-takashimadaira');
    const btnAr = document.getElementById('btn-dungeon-arakawa');
    const btnNa = document.getElementById('btn-dungeon-national');
    if (!btnAk || !btnTa || !btnAr || !btnNa) return;

    // å¸¸ã«è§£æ”¾ã•ã‚Œã¦ã„ã‚‹èµ¤å¡šå…¬åœ’
    btnAk.innerText = `ğŸŒ³ ${DUNGEONS.akatsuka.name}ï¼ˆåˆç´šï¼‰`;
    btnAk.classList.remove('disabled');

    // é«˜å³¶å¹³
    if (isDungeonUnlocked('takashimadaira')) {
      btnTa.innerText = `ğŸ™ï¸ ${DUNGEONS.takashimadaira.name}ï¼ˆä¸­ç´šï¼‰`;
      btnTa.classList.remove('disabled');
    } else {
      btnTa.innerText = 'ï¼Ÿï¼Ÿï¼Ÿ';
      btnTa.classList.add('disabled');
    }

    // è’å·
    if (isDungeonUnlocked('arakawa')) {
      btnAr.innerText = `ğŸŒŠ ${DUNGEONS.arakawa.name}ï¼ˆä¸Šç´šï¼‰`;
      btnAr.classList.remove('disabled');
    } else {
      btnAr.innerText = 'ï¼Ÿï¼Ÿï¼Ÿ';
      btnAr.classList.add('disabled');
    }

    // å…¨å›½ä¸€æ–‰ï¼ˆæœ€çµ‚ï¼‰
    if (isDungeonUnlocked('national')) {
      btnNa.innerText = `ğŸŒ ${DUNGEONS.national.name}ï¼ˆæœ€çµ‚ï¼‰`;
      btnNa.classList.remove('disabled');
    } else {
      btnNa.innerText = 'ï¼Ÿï¼Ÿï¼Ÿ';
      btnNa.classList.add('disabled');
    }
  }
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const floor1 = (v)=>Math.max(1, Math.floor(v));

  function critChance(luk){ return clamp(luk * 0.005, 0, 0.25); }
  function dodgeChance(spd, enemySpd){ return clamp((spd - enemySpd) * 0.03, 0, 0.25); }
  function reduceDamage(raw, def){
    return floor1(raw * 100 / (100 + Math.max(0, def)));
  }

  const canvas = document.getElementById('game-canvas');
  const ctx = canvas.getContext('2d');

  function resizeCanvas() {
    const container = document.getElementById('screen-container');
    canvas.width = container.clientWidth;
    canvas.height = 200;
  }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  const assetStatusEl = document.getElementById('asset-status');

  function loadImage(src) {
    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => resolve({ ok: true, img, src });
      img.onerror = () => resolve({ ok: false, img: null, src });
      img.src = src;
    });
  }

  const ASSET_PATH = "assets/";

  const ASSET_LIST = {
    sy:     ASSET_PATH + "support/yuzuki/yuzuki.png",
    sm:     ASSET_PATH + "support/mirako/mirako.png",
    sf:     ASSET_PATH + "support/fromzero/fromzero.png",

    road:   ASSET_PATH + "road_tiles.png",
    build:  ASSET_PATH + "building_tiles.png",
    civic:  ASSET_PATH + "service_buildings.png",
    player: ASSET_PATH + "player_sheet.jpg",
    e1:     ASSET_PATH + "enemy_1_cutout.png",
    e2:     ASSET_PATH + "enemy_2_cutout.png",
    e3:     ASSET_PATH + "enemy_3_cutout.png",
  };

  const ASSETS = {
    supportY:{ img: null, ok: false },
    supportM:{ img: null, ok: false },
    supportF:{ img: null, ok: false },
    road:  { img: null, ok: false },
    build: { img: null, ok: false },
    civic: { img: null, ok: false },
    player:{ img: null, ok: false },
    enemy1:{ img: null, ok: false },
    enemy2:{ img: null, ok: false },
    enemy3:{ img: null, ok: false },
  };

  const ROAD_TILES  = { get img(){ return ASSETS.road.img;  }, get ready(){ return ASSETS.road.ok;  }, tileSize: 128, cols: 8 };
  const BUILD_TILES = { get img(){ return ASSETS.build.img; }, get ready(){ return ASSETS.build.ok; }, tileSize: 256, cols: 6 };
  const CIVIC_TILES = { get img(){ return ASSETS.civic.img; }, get ready(){ return ASSETS.civic.ok; }, tileSize: 0, cols: 3 };

  async function loadAllAssets() {
    const keys = Object.keys(ASSET_LIST);
    const results = await Promise.all(keys.map(k => loadImage(ASSET_LIST[k])));
    const bySrc = new Map(results.map(r => [r.src, r]));

    function put(targetKey, src) {
      const r = bySrc.get(src);
      ASSETS[targetKey].ok = !!r?.ok;
      ASSETS[targetKey].img = r?.img || null;
    }

    put("supportY", ASSET_LIST.sy);
    put("supportM", ASSET_LIST.sm);
    put("supportF", ASSET_LIST.sf);
    put("road",  ASSET_LIST.road);
    put("build", ASSET_LIST.build);
    put("civic", ASSET_LIST.civic);
    put("player",ASSET_LIST.player);
    put("enemy1",ASSET_LIST.e1);
    put("enemy2",ASSET_LIST.e2);
    put("enemy3",ASSET_LIST.e3);

    if (ASSETS.civic.ok && ASSETS.civic.img) {
      CIVIC_TILES.cols = 3;
      CIVIC_TILES.tileSize = Math.floor(ASSETS.civic.img.width / 3);
      if (!CIVIC_TILES.tileSize || CIVIC_TILES.tileSize < 1) CIVIC_TILES.tileSize = 64;
    }

    updateAssetStatus();
  }

  function updateAssetStatus() {
    const s = (ok)=> ok ? "OK" : "NG";
    assetStatusEl.innerText =
      `ASSET\n`+
      `road:${s(ASSETS.road.ok)} build:${s(ASSETS.build.ok)} civic:${s(ASSETS.civic.ok)}\n`+
      `ply:${s(ASSETS.player.ok)} e1:${s(ASSETS.enemy1.ok)} e2:${s(ASSETS.enemy2.ok)} e3:${s(ASSETS.enemy3.ok)}`;
  }

  const ENEMY_IMG = {
    enemy1: { get img(){ return ASSETS.enemy1.img; }, get ready(){ return ASSETS.enemy1.ok; } },
    enemy2: { get img(){ return ASSETS.enemy2.img; }, get ready(){ return ASSETS.enemy2.ok; } },
    enemy3: { get img(){ return ASSETS.enemy3.img; }, get ready(){ return ASSETS.enemy3.ok; } },
  };

  function drawEnemySprite(enemy, x, y) {
    if (!enemy) return;

    const key = enemy.imgKey;
    const pack = key ? ENEMY_IMG[key] : null;

    if (pack && pack.ready && pack.img) {
      const img = pack.img;
      const targetW = Math.floor(canvas.width * 0.34);
      const scale = targetW / img.width;
      const dw = Math.floor(img.width * scale);
      const dh = Math.floor(img.height * scale);

      ctx.save();
      ctx.imageSmoothingEnabled = true;
      ctx.drawImage(img, x - dw/2, y - dh/2, dw, dh);
      ctx.restore();
      return;
    }

    ctx.save();
    ctx.font = "48px 'DotGothic16', monospace";
    ctx.textAlign = "center";
    ctx.fillText(enemy.e || "ğŸ‘¾", x, y);
    ctx.restore();
  }

  function drawTileSheet(tilePack, tileId, dx, dy, dw, dh, fallbackColor) {
    if (!tilePack.ready || !tilePack.img || !tilePack.tileSize) {
      ctx.fillStyle = fallbackColor || "#333";
      ctx.fillRect(dx, dy, dw, dh);
      ctx.save();
      ctx.globalAlpha = 0.9;
      ctx.fillStyle = "#ff4444";
      ctx.font = "10px 'DotGothic16'";
      ctx.textAlign = "left";
      ctx.textBaseline = "top";
      ctx.fillText("IMG?", dx + 2, dy + 2);
      ctx.restore();
      return;
    }
    const ts = tilePack.tileSize;
    const sx = (tileId % tilePack.cols) * ts;
    const sy = Math.floor(tileId / tilePack.cols) * ts;
    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(tilePack.img, sx, sy, ts, ts, dx, dy, dw, dh);
  }

  const TILE_GRASS = 0;
  const TILE_ROAD  = 1;

  const BLD_EMPTY = -1;
  const BLD_HUT   = 0;
  const BLD_HOUSE = 1;
  const BLD_APT   = 2;
  const BLD_BIG   = 3;
  const BLD_PARK  = 10;
  const BLD_TREE  = 16;

  const BLD_POLICE   = 100;
  const BLD_FIRE     = 101;
  const BLD_HOSPITAL = 102;

  function isFacilityTile(id) {
    return id === BLD_POLICE || id === BLD_FIRE || id === BLD_HOSPITAL;
  }
  function civicTileIdOfBuildingId(id) {
    if (id === BLD_POLICE) return 0;
    if (id === BLD_FIRE) return 1;
    if (id === BLD_HOSPITAL) return 2;
    return -1;
  }

  const TOWN_W = 16;
  const TOWN_H = 9;

  let townMap = Array.from({ length: TOWN_H }, (_, y) =>
    Array.from({ length: TOWN_W }, (_, x) =>
      (y === Math.floor(TOWN_H / 2) ? TILE_ROAD : TILE_GRASS)
    )
  );

  let buildingMap = Array.from({ length: TOWN_H }, () =>
    Array.from({ length: TOWN_W }, () => BLD_EMPTY)
  );

  let infected = Array.from({ length: TOWN_H }, () =>
    Array.from({ length: TOWN_W }, () => 0)
  );

  const RARITY_MULT = { 1: 0.6, 2: 0.8, 3: 1.0, 4: 1.25, 5: 1.55 };

  const SUPPORT_MASTER = {
    yuzuki: {
      name: "ã‚†ã¥ã",
      icon: "âœ¨",
      imgKey: "supportY",
      base: { atk: 15, def: 0, spd: 1, maxHp: 0 },
      skill: { id: "focus_clean", name: "é›†ä¸­æ¸…æƒ" }
    },
    mirako: {
      name: "ã¿ã‚‰ã“",
      icon: "ğŸŒ¸",
      imgKey: "supportM",
      base: { atk: 2, def: 3, spd: 2, maxHp: 20 },
      skill: { id: "env_barrier", name: "ç’°å¢ƒãƒãƒªã‚¢" }
    },
    fromzero: {
      name: "FromZero",
      icon: "ğŸ§¹",
      imgKey: "supportF",
      base: { atk: 4, def: 1, spd: 0, maxHp: 30 },
      skill: { id: "zero_restart", name: "ã‚¼ãƒ­ã‹ã‚‰ã®ã‚¹ã‚¿ãƒ¼ãƒˆ" }
    }
  };

  const DUPE_RATE = { 1: 0.01, 2: 0.02, 3: 0.04, 4: 0.07, 5: 0.10 };

  function rarityColor(r) {
    if (r === 1) return "#ffffff";
    if (r === 2) return "#22c55e";
    if (r === 3) return "#3b82f6";
    if (r === 4) return "#a855f7";
    if (r === 5) return "#ef4444";
    return "#ffffff";
  }
  function rarityText(r, dupes = 0) {
    const stars = "â˜…".repeat(r);
    return dupes > 0 ? `${stars}+${dupes}` : stars;
  }
  function rarityBadgeHTML(r, dupes = 0) {
    const color = rarityColor(r);
    const txt = rarityText(r, dupes);
    return `<span style="color:${color}; font-weight:bold;">${txt}</span>`;
  }
  function getSupportSkillDisplayName(unit) {
    if (!unit) return "-";
    const m = SUPPORT_MASTER[unit.masterId];
    if (!m) return "-";
    if (unit.masterId === "yuzuki" && (unit.rarity ?? 1) >= 4) return `${m.skill.name}(æ”¹)`;
    return m.skill.name;
  }

  let state = {
    mode: 'town',     // town / dungeon / battle
    uiTab: 'town',    // town / shop / explore

trust: 0, // âœ… ä¿¡é ¼ã‚²ãƒ¼ã‚¸ï¼ˆ0ã€œ100ï¼‰
    // âœ… ä¿¡é ¼ã‚²ãƒ¼ã‚¸ã®ä¸Šé™ï¼ˆåˆæœŸ25ã€‚èµ¤å¡šå…¬åœ’ã‚¯ãƒªã‚¢å¾Œã«50ã«æ‹¡å¼µï¼‰
    trustMax: 25,
    money: 500,
    population: 100,
    staff: 0,
    staffCost: 300,
    stats: { env: 80, security: 80, health: 80 },
    wasteRate: 0,
    inventory: [],
    player: {
      lv: 1, xp: 0, next: 50,
      hp: 100, maxHp: 100,
      baseAtk: 12,
      baseDef: 0,
      baseSpd: 5,
      baseLuk: 5,
      drinks: 1,
      bagId: 'bag_s',
      equip: { weapon: null, hand: null, body: null },
    },
    loot: { cur: 0, max: 100 },
    distance: 0,
    enemy: null,
    battle: { isPlayerTurn: false, isAnimating: false, defending: false },
    lastTick: Date.now(),
    lastDisasterAt: 0,
    placing: { active: false, type: null },
    patrol: { until: 0 },
    dungeon: { bossSpawned: false, bossDefeated: false, zeroUsed: false },

    // ç¾åœ¨é¸æŠä¸­ã®ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³ID
    selectedDungeon: "akatsuka",
    // âœ… ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³ã‚¯ãƒªã‚¢çŠ¶æ³ï¼ˆåˆæœŸã¯å…¨ã¦æœªã‚¯ãƒªã‚¢ï¼‰
    cleared: { akatsuka: false, takashimadaira: false, arakawa: false },

    // âœ… ãƒ•ãƒ©ã‚°ç®¡ç†ï¼ˆã‚¤ãƒ™ãƒ³ãƒˆç”¨ï¼‰
    flags: {
      // èµ¤å¡šå…¬åœ’ã‚¯ãƒªã‚¢å¾Œã‚¤ãƒ™ãƒ³ãƒˆï¼ˆæ¿æ©‹ã‚¤ãƒ™ãƒ³ãƒˆï¼‰ãŒå®Ÿè¡Œæ¸ˆã¿ã‹
      itabashiEventDone: false
    },
    // âœ… è»¢ç”Ÿå›æ•°ã‚’ãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°ï¼ˆåˆæœŸå€¤0ï¼‰
    reincarnations: 0,

    // âœ… ä¸–ç•Œå´©å£Šãƒ•ã‚§ãƒ¼ã‚º state
    collapse: {
  active: false,
  enteredOnce: false,
  overlayUntil: 0,
  driftEventFired: false,
  tutorialBossDefeated: false,
  cooldownUntil: 0,
  recoverHoldMs: 0,
  recoverLastAt: 0,

  // âœ… è¿½åŠ ï¼šå›½æ°‘ç·æ”¯æ´ã®åŠ¹æœãŒç¶šãæœŸé™
  supportUntil: 0
},
    supports: {
      inventory: [],
      slots: { slot1: null, slot2: null, slot3: null }
    },

    _supportMigrated_v2: false
  };

  const DISASTER_COOLDOWN_MS = 30_000;
  const ARSON_POP_LOSS_RATE = 0.03;
  const THEFT_MONEY_LOSS_RATE = 0.03;
  const DISEASE_POP_LOSS_RATE = 0.02;

  const FACILITY_COST  = { hospital: 2500, police: 6000, fire: 6000 };
  const FACILITY_LIMIT = { hospital: 5, police: 99, fire: 99 };

  const POP_LOSS_BY_BUILDING = { hut: 10, house: 20, apt: 35, big: 50, park: 0, tree: 0 };

  // =========================
  // ãƒ‘ãƒˆãƒ­ãƒ¼ãƒ«ï¼ˆæ²»å®‰ãƒ–ãƒ¼ã‚¹ãƒˆï¼‰
  // =========================
  const PATROL_COST = 400;
  const PATROL_DURATION_MS = 60_000; // 60ç§’
  const PATROL_SECURITY_GAIN = 10;   // å³æ™‚æ²»å®‰+10
  const PATROL_REGEN_BONUS = 0.8;    // æ¯ç§’ã®æ²»å®‰å›å¾©+0.8ï¼ˆãƒ‘ãƒˆãƒ­ãƒ¼ãƒ«ä¸­ï¼‰
  const PATROL_CRIME_REDUCE_BONUS = 0.20;

  function isPatrolActive() {
    return (state.patrol?.until ?? 0) > Date.now();
  }

  function startPatrol() {
    if (isPatrolActive()) {
      const left = Math.ceil((state.patrol.until - Date.now()) / 1000);
      logMessage(`ğŸš¶ ãƒ‘ãƒˆãƒ­ãƒ¼ãƒ«ä¸­ã§ã™ï¼ˆæ®‹ã‚Š ${left}sï¼‰`);
      addTrust(2, "ãƒ‘ãƒˆãƒ­ãƒ¼ãƒ«");
      updateUI();
      return;
    }

    if (state.mode !== 'town' || state.uiTab !== 'town') {
      logMessage("è¡—ã«ã„ã‚‹æ™‚ã ã‘ãƒ‘ãƒˆãƒ­ãƒ¼ãƒ«ã§ãã¾ã™ã€‚");
      return;
    }

    if (state.money < PATROL_COST) {
      openModal("è³‡é‡‘ãŒè¶³ã‚Šã¾ã›ã‚“ã€‚");
      return;
    }

    state.money -= PATROL_COST;
    state.patrol.until = Date.now() + PATROL_DURATION_MS;

    state.stats.security = clamp(state.stats.security + PATROL_SECURITY_GAIN, 0, 100);

    logMessage(`ğŸš¶ ãƒ‘ãƒˆãƒ­ãƒ¼ãƒ«é–‹å§‹ï¼æ²»å®‰ +${PATROL_SECURITY_GAIN}ï¼ˆ60ç§’é–“ãƒ–ãƒ¼ã‚¹ãƒˆï¼‰`);
    updateUI();
    saveGame();
  }

  // é å¾å…ˆã‚’é¸æŠã™ã‚‹
  function selectDungeon(id) {
    // å­˜åœ¨ã—ãªã„IDã€ã¾ãŸã¯æœªè§£æ”¾ã®IDãŒæŒ‡å®šã•ã‚ŒãŸå ´åˆã¯ç„¡è¦–
    if (!DUNGEONS[id] || !isDungeonUnlocked(id)) return;
    state.selectedDungeon = id;
    const d = DUNGEONS[id];
    logMessage(`ğŸ—ºï¸ é å¾å…ˆã‚’ã€Œ${d.name}ã€ã«è¨­å®šã—ã¾ã—ãŸ`);
    updateUI();
    saveGame();
  }
// âœ… å´©å£Šè§£é™¤æ¡ä»¶ï¼ˆæ–°ï¼‰
// ã‚´ãƒŸ1å„„ä»¥ä¸‹ ï¼‹ ç’°å¢ƒ/æ²»å®‰/å¥åº·30%ä»¥ä¸Š ã‚’ä¸€å®šæ™‚é–“ä¿æŒ
const RECOVER_THRESHOLD = 30;
const RECOVER_WASTE_MAX = 100_000_000;
const RECOVER_HOLD_MS   = 30_000; // 30ç§’ï¼ˆå¥½ã¿ã§å¤‰æ›´OKï¼‰
  // =========================================================
  // âœ… ä¸–ç•Œå´©å£Šãƒ•ã‚§ãƒ¼ã‚ºï¼ˆå®Ÿè£…ï¼‰
  // =========================================================
  function ensureCollapseState() {
  if (!state.collapse) {
  state.collapse = {
    active: false,
    enteredOnce: false,
    overlayUntil: 0,
    driftEventFired: false,
    tutorialBossDefeated: false,
    cooldownUntil: 0,
    recoverHoldMs: 0,
    recoverLastAt: 0,
    supportUntil: 0 // âœ… è¿½åŠ 
  };
  return;
}
// å›½æ°‘ç·æ”¯æ´ï¼ˆä»Šå›è¿½åŠ åˆ†ï¼‰
if (state.collapse.supportUntil == null) state.collapse.supportUntil = 0;
  // æ—¢å­˜ã‚»ãƒ¼ãƒ–äº’æ›ï¼ˆå¤ã„ã‚»ãƒ¼ãƒ–ã«é …ç›®ãŒç„¡ã„å ´åˆï¼‰
  if (state.collapse.active == null) state.collapse.active = false;
  if (state.collapse.enteredOnce == null) state.collapse.enteredOnce = false;
  if (state.collapse.overlayUntil == null) state.collapse.overlayUntil = 0;
  if (state.collapse.driftEventFired == null) state.collapse.driftEventFired = false;
  if (state.collapse.tutorialBossDefeated == null) state.collapse.tutorialBossDefeated = false;
  if (state.collapse.cooldownUntil == null) state.collapse.cooldownUntil = 0;

  // è§£é™¤æ¡ä»¶ã®ä¿æŒã‚¿ã‚¤ãƒãƒ¼ï¼ˆä»Šå›è¿½åŠ åˆ†ï¼‰
  if (state.collapse.recoverHoldMs == null) state.collapse.recoverHoldMs = 0;
  if (state.collapse.recoverLastAt == null) state.collapse.recoverLastAt = 0;
}

  function showCollapseOverlay(ms = 2000) {
    const el = document.getElementById("collapse-overlay");
    if (!el) return;
    el.style.display = "flex";
    state.collapse.overlayUntil = Date.now() + ms;
  }

  function tickCollapseOverlay() {
    const el = document.getElementById("collapse-overlay");
    if (!el) return;
    if (!state.collapse?.active) { el.style.display = "none"; return; }

    if (Date.now() > (state.collapse.overlayUntil || 0)) {
      el.style.display = "none";
    } else {
      el.style.display = "flex";
    }
  }

  function enterCollapsePhase(reasonText = "è‡¨ç•Œåˆ°é”") {
    ensureCollapseState();
    if (state.collapse.active) return;

    state.collapse.active = true;
    state.collapse.enteredOnce = true;

    const t = document.getElementById("collapse-text");
    if (t) {
      t.innerHTML =
        `å´©å£ŠãŒå§‹ã¾ã‚Šã¾ã—ãŸã€‚<br>` +
        `ç’°å¢ƒãƒ»æ²»å®‰ãƒ»å¥åº·ãŒæ€¥æ¿€ã«æ‚ªåŒ–ã—ã¾ã™ã€‚<br>` +
        `<span style="color:#f87171;">åŸå› ï¼š</span>${reasonText}`;
    }
    showCollapseOverlay(2200);

    // âœ… ä»¥å‰ã€Œé å¾ä¸­(dungeon)ã€ã®ã¾ã¾ã‚¢ãƒ—ãƒªã‚’é–‰ã˜ãŸçŠ¶æ…‹ã§å´©å£ŠãŒç™ºç”Ÿã™ã‚‹ã¨ã€
    //    ã‚¿ãƒ–ãŒã€Œé å¾ä¸­ãƒ­ãƒƒã‚¯ã€ã®ã¾ã¾ã«ãªã‚Šæ“ä½œä¸èƒ½ã«ãªã‚ŠãŒã¡ã€‚
    //    å´©å£Šçªå…¥æ™‚ã¯å¿…ãšè¡—ã¸æˆ»ã—ã¦UIã‚’å¾©å¸°ã•ã›ã‚‹ã€‚
    if (state.mode !== 'town') {
      try {
        returnTown(true);
      } catch (e) {
        state.mode = 'town';
        state.uiTab = 'town';
      }
    }

    logMessage("âš  ä¸–ç•Œå´©å£Šãƒ•ã‚§ãƒ¼ã‚ºã«çªå…¥â€¦ï¼");
    updateUI();
    saveGame();
  }

  // è§£é™¤æ¡ä»¶ï¼ˆä¾‹ï¼‰ï¼šç’°å¢ƒ/æ²»å®‰/å¥åº·ãŒå…¨ã¦80%ä»¥ä¸Š
  function forceReincarnate(reason = "è»¢ç”Ÿ") {
  // âœ… å¼•ãç¶™ããŸã„ã‚‚ã®ãŒã‚ã‚Œã°ã“ã“ã§é€€é¿
  const keep = {
    reincarnations: (state.reincarnations ?? 0) + 1,
    // ä¾‹ï¼šã‚¬ãƒãƒ£ã‚µãƒãƒ¼ãƒˆã ã‘æ®‹ã™ãªã‚‰
    supports: state.supports ? structuredClone(state.supports) : null,
    _supportMigrated_v2: state._supportMigrated_v2 ?? false,
    // âœ… ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³ã‚¯ãƒªã‚¢çŠ¶æ³ã‚‚è»¢ç”Ÿå¾Œã«ç¶­æŒ
    cleared: state.cleared ? structuredClone(state.cleared) : { akatsuka: false, takashimadaira: false, arakawa: false }
  };

  // âœ… åˆæœŸåŒ–ï¼ˆï¼è»¢ç”Ÿï¼‰
  state = {
    mode: 'town',
    uiTab: 'town',
    trust: 0,
    money: 500,
    population: 100,
    staff: 0,
    staffCost: 300,
    stats: { env: 80, security: 80, health: 80 },
    wasteRate: 0,
    inventory: [],
    player: {
      lv: 1, xp: 0, next: 50,
      hp: 100, maxHp: 100,
      baseAtk: 12,
      baseDef: 0,
      baseSpd: 5,
      baseLuk: 5,
      drinks: 1,
      bagId: 'bag_s',
      equip: { weapon: null, hand: null, body: null },
    },
    loot: { cur: 0, max: 100 },
    distance: 0,
    enemy: null,
    battle: { isPlayerTurn: false, isAnimating: false, defending: false },
    lastTick: Date.now(),
    lastDisasterAt: 0,
    placing: { active: false, type: null },
    patrol: { until: 0 },
    dungeon: { bossSpawned: false, bossDefeated: false, zeroUsed: false },
    collapse: {
      active: false,
      enteredOnce: false,
      overlayUntil: 0,
      driftEventFired: false,
      tutorialBossDefeated: false,
      cooldownUntil: 0,
      recoverHoldMs: 0,
      recoverLastAt: 0,
      supportUntil: 0
    },
    supports: { inventory: [], slots: { slot1: null, slot2: null, slot3: null } },
    _supportMigrated_v2: false
  };

  // âœ… å¼•ãç¶™ãå¾©å…ƒ
  state.reincarnations = keep.reincarnations;
  // âœ… è»¢ç”Ÿå¾Œã§ã‚‚ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³ã‚¯ãƒªã‚¢çŠ¶æ³ã‚’å¼•ãç¶™ã
  state.cleared = keep.cleared;
  if (keep.supports) {
    state.supports = keep.supports;
    state._supportMigrated_v2 = keep._supportMigrated_v2;
  }

  // âœ… åˆæœŸæ‰€æŒä¿è¨¼
  ensureDefaultBagOwned();
  ensureCollapseState();
  ensureSupportState();

    // --- New Game Reset Fix ---
    // When reincarnating (i.e. starting a new game), ensure that
    // the timing fields are reset so that offline progress does not
    // immediately apply a long gap and deteriorate the stats.  In
    // previous versions, state.lastTick was not updated prior to
    // saving, causing applyOfflineProgress() to calculate a huge
    // delta between the last tick and now on the next page load.
    // This resulted in environment/health dropping to 0 and
    // population falling to the minimum value of 10.  To prevent this,
    // set lastTick to the current time (and reset disaster timers)
    // before saving so that applyOfflineProgress() sees no elapsed
    // downtime on the next load.  Also reset lastDisasterAt to 0 so
    // the collapse cooldown state does not carry over inadvertently.
    state.lastTick = Date.now();
    state.lastDisasterAt = 0;


  // âœ… ç”»é¢ã‚’è¡—ã«æˆ»ã™
  document.getElementById('ui-town-ctrl')?.classList.remove('hidden');
  document.getElementById('ui-dungeon-ctrl')?.classList.add('hidden');
  document.getElementById('ui-battle-ctrl')?.classList.add('hidden');
  document.getElementById('battle-hud')?.classList.add('hidden');
  showTab('town');

  logMessage(`ğŸŒ€ å¼·åˆ¶è»¢ç”Ÿï¼š${reason}`);
  saveGame();
  updateUI();
}
  
  function tryExitCollapsePhase() {
  ensureCollapseState();
  if (!state.collapse.active) return;

  const now = Date.now();

  // âœ… å¾©èˆˆè§£é™¤ï¼ˆå¾“æ¥ï¼‰ï¼šenv/sec/heal å…¨ã¦80%ä»¥ä¸Š
  const recovered =
    (state.stats.env >= 80) &&
    (state.stats.security >= 80) &&
    (state.stats.health >= 80);

  // âœ… å£Šæ»…è§£é™¤ï¼ˆæ•‘æ¸ˆï¼‰ï¼šäººå£10ä»¥ä¸‹ & ã‚´ãƒŸ0.5ä»¥ä¸‹
    // âœ… å£Šæ»…è§£é™¤ï¼ˆæ•‘æ¸ˆï¼‰ï¼šäººå£10ä»¥ä¸‹ï¼ˆäººå£10ã¯ã‚²ãƒ¼ãƒ å†…ã§ä¸‹é™ãªã®ã§ã€Œåˆ°é”ã—ãŸã‚‰è§£é™¤ã€æ‰±ã„ã«ã™ã‚‹ï¼‰
  const devastated = (state.population <= 10);

  // âœ… æ•‘æ¸ˆè§£é™¤ï¼ˆæ–°ï¼‰ï¼šã‚´ãƒŸ1å„„ä»¥ä¸‹ ï¼‹ env/sec/healãŒ30%ä»¥ä¸Šã‚’ä¸€å®šæ™‚é–“ç¶­æŒ
  const okStats =
    (state.stats.env >= RECOVER_THRESHOLD) &&
    (state.stats.security >= RECOVER_THRESHOLD) &&
    (state.stats.health >= RECOVER_THRESHOLD);

  const okWaste = (state.wasteRate ?? 0) <= RECOVER_WASTE_MAX;

  let recoveredByHold = false;

  if (okStats && okWaste) {
    if (!state.collapse.recoverLastAt) state.collapse.recoverLastAt = now;
    const dt = now - state.collapse.recoverLastAt;

    state.collapse.recoverHoldMs = (state.collapse.recoverHoldMs ?? 0) + dt;
    state.collapse.recoverLastAt = now;

    if (state.collapse.recoverHoldMs >= RECOVER_HOLD_MS) {
      recoveredByHold = true;
    }
  } else {
    // æ¡ä»¶ãŒå´©ã‚ŒãŸã‚‰ãƒªã‚»ãƒƒãƒˆ
    state.collapse.recoverHoldMs = 0;
    state.collapse.recoverLastAt = now;
  }

  // âœ… è§£é™¤åˆ¤å®š
  if (!(recovered || recoveredByHold || devastated)) return;

  // âœ… è§£é™¤å‡¦ç†
  state.collapse.active = false;

  // âœ… è§£é™¤ç›´å¾Œã®å³å†çªå…¥ã‚’é˜²ãï¼ˆ5ç§’ï¼‰
  state.collapse.cooldownUntil = now + 5000;

  if (devastated) {
    // å£Šæ»…è§£é™¤ï¼šå³å†çªå…¥ã‚’é¿ã‘ã‚‹æœ€ä½é™ã®åº•ä¸Šã’
    state.stats.env = Math.max(state.stats.env, 5);
    state.stats.security = Math.max(state.stats.security, 5);
    state.stats.health = Math.max(state.stats.health, 5);
    logMessage("ğŸ•¯ï¸ å´©å£Šã¯çµ‚ã‚ã£ãŸâ€¦ï¼ˆå£Šæ»…ï¼‰ã€‚ã“ã“ã‹ã‚‰â€œã‚¼ãƒ­ã‹ã‚‰ã®å†å»ºâ€ãŒå§‹ã¾ã‚‹ã€‚");
  } else if (recoveredByHold) {
    logMessage("ğŸŒ± ãªã‚“ã¨ã‹è¸ã¿ã¨ã©ã¾ã£ãŸâ€¦ï¼ˆæ•‘æ¸ˆè§£é™¤ï¼‰ã€‚è¡—ã¯å†å»ºã¸å‘ã‹ã†ï¼");
  } else {
    logMessage("âœ¨ å´©å£Šã‚’é£Ÿã„æ­¢ã‚ãŸâ€¦è¡—ã¯æŒã¡ç›´ã—ãŸï¼");
  }

  const el = document.getElementById("collapse-overlay");
  if (el) el.style.display = "none";

  updateUI();
  saveGame();
}  // å´©å£Šä¸­ã®æ¯ç§’å‡¦ç†ï¼ˆå¼·åˆ¶çš„ã«æ‚ªåŒ–ï¼‰
  function applyCollapseTick() {
  ensureCollapseState();
  if (!state.collapse.active) return;

  const now = Date.now();
  const supporting = now < (state.collapse.supportUntil || 0);

  // âœ… æ”¯æ´ä¸­ã¯æ‚ªåŒ–ã‚’å¼±ã‚ã‚‹ï¼ˆæŠ‘åˆ¶ï¼‰
  const envDown = supporting ? 0.55 : 1.2;
  const secDown = supporting ? 0.45 : 1.0;
  const heaDown = supporting ? 0.45 : 1.0;

  const wasteUp = supporting ? 0.8 : 2.0;

  // âœ… äººå£æ¸›å°‘ã‚‚å°‘ã—æŠ‘ãˆã‚‹
  const popMul = supporting ? 0.995 : 0.99;

  state.stats.env      = clamp(state.stats.env      - envDown, 0, 100);
  state.stats.security = clamp(state.stats.security - secDown, 0, 100);
  state.stats.health   = clamp(state.stats.health   - heaDown, 0, 100);

  state.wasteRate += wasteUp;
  state.population = Math.max(10, Math.floor(state.population * popMul));

  tickCollapseOverlay();
  tryExitCollapsePhase();
}

  function checkCollapseTriggers() {
    ensureCollapseState();
    if (state.collapse.active) return;

  // âœ… è¿½åŠ ï¼šè§£é™¤ç›´å¾Œã¯å†çªå…¥ã—ãªã„
  if (Date.now() < (state.collapse.cooldownUntil || 0)) return;

    // åˆå›ï¼šèµ¤å¡šå…¬åœ’ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ãƒœã‚¹æ’ƒç ´å¾Œã«å¼·åˆ¶çªå…¥
    if (!state.collapse.enteredOnce && state.collapse.tutorialBossDefeated) {
      enterCollapsePhase("èµ¤å¡šå…¬åœ’ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ï¼šãƒœã‚¹æ’ƒç ´å¾Œã®å´©å£Šçªå…¥");
      return;
    }

    // 2å›ç›®ä»¥é™ï¼štrash overflow
    if ((state.wasteRate ?? 0) >= 1_000_000_000) {
      enterCollapsePhase("OVERFLOWï¼šã‚´ãƒŸãŒè‡¨ç•Œï¼ˆ1,000,000,000ï¼‰ã‚’çªç ´");
      return;
    }

    // env/sec/heal ã®ã†ã¡2ã¤ä»¥ä¸ŠãŒ0
    const zeros =
      (state.stats.env <= 0 ? 1 : 0) +
      (state.stats.security <= 0 ? 1 : 0) +
      (state.stats.health <= 0 ? 1 : 0);
    if (zeros >= 2) {
      enterCollapsePhase("è‡¨ç•Œï¼šç’°å¢ƒ/æ²»å®‰/å¥åº·ã®ã†ã¡2ã¤ãŒ0%");
      return;
    }

    // è’å·ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³ã€Œå¤§é‡æ¼‚ç€ãƒã‚¤ãƒ³ãƒˆã€ã‚¤ãƒ™ãƒ³ãƒˆç™ºç”Ÿï¼ˆå°†æ¥ç”¨ï¼‰
    if (state.collapse.driftEventFired) {
      enterCollapsePhase("è’å·ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³ï¼šå¤§é‡æ¼‚ç€ãƒã‚¤ãƒ³ãƒˆç™ºç”Ÿ");
      state.collapse.driftEventFired = false; // é€£ç¶šç™ºç«é˜²æ­¢
      return;
    }
  }

  function ensureSupportState() {
    if (!state.supports) state.supports = { inventory: [], slots: { slot1: null, slot2: null, slot3: null } };
    if (!state.supports.inventory) state.supports.inventory = [];
    if (!state.supports.slots) state.supports.slots = { slot1: null, slot2: null, slot3: null };
  }

  function migrateSupportsIfNeeded() {
    if (!state._supportMigrated_v2) {
      state.supports = { inventory: [], slots: { slot1: null, slot2: null, slot3: null } };
      state._supportMigrated_v2 = true;
    }
  }

  function getSupportUnit(uid) {
    ensureSupportState();
    return state.supports.inventory.find(u => u.uid === uid) || null;
  }

  function getEquippedSupports() {
    ensureSupportState();
    const ids = Object.values(state.supports.slots).filter(Boolean);
    return ids.map(getSupportUnit).filter(Boolean);
  }

  function calcSupportBonus() {
    ensureSupportState();
    const units = getEquippedSupports();
    let b = { atk: 0, def: 0, spd: 0, maxHp: 0 };

    for (const u of units) {
      const m = SUPPORT_MASTER[u.masterId];
      if (!m) continue;

      const rarity = u.rarity ?? 1;
      const rMul = RARITY_MULT[rarity] ?? 1.0;

      const level = u.level ?? 1;
      const lvMul = 1 + Math.max(0, level - 1) * 0.06;

      const dupes = u.dupes ?? 0;
      const rate = DUPE_RATE[rarity] ?? 0;
      const dupeMul = 1 + (dupes * rate);

      const mul = rMul * lvMul * dupeMul;

      b.atk   += Math.floor((m.base.atk   ?? 0) * mul);
      b.def   += Math.floor((m.base.def   ?? 0) * mul);
      b.spd   += Math.floor((m.base.spd   ?? 0) * mul);
      b.maxHp += Math.floor((m.base.maxHp ?? 0) * mul);
    }
    return b;
  }

  function countFacility(type) {
    const id = type === 'hospital' ? BLD_HOSPITAL : type === 'police' ? BLD_POLICE : BLD_FIRE;
    let c = 0;
    for (let y = 0; y < TOWN_H; y++) for (let x = 0; x < TOWN_W; x++) {
      if (buildingMap[y][x] === id) c++;
    }
    return c;
  }

  function getFacilityEffects() {
    const p = countFacility('police');
    const f = countFacility('fire');
    const h = countFacility('hospital');

    const securityRegen = Math.min(1.2, 0.15 * p);
    const crimeReduce   = Math.min(0.75, 0.18 * p);
    const fireSuccessChance = Math.min(0.90, 0.25 + 0.18 * f);
    const healthRegen = Math.min(1.0, 0.18 * h);
    const diseaseReduce = Math.min(0.70, 0.15 * h);

    return { securityRegen, crimeReduce, fireSuccessChance, healthRegen, diseaseReduce };
  }

  function selectFacilityToPlace(type) {
    const limit = FACILITY_LIMIT[type] ?? 99;
    if (countFacility(type) >= limit) {
      openModal(`${type === 'hospital' ? 'ç—…é™¢' : type === 'police' ? 'è­¦å¯Ÿç½²' : 'æ¶ˆé˜²ç½²'}ã¯ä¸Šé™ï¼ˆ${limit}ï¼‰ã«é”ã—ã¦ã„ã¾ã™ã€‚`);
      return;
    }
    const cost = FACILITY_COST[type] ?? 0;
    if (state.money < cost) {
      openModal("è³‡é‡‘ãŒè¶³ã‚Šã¾ã›ã‚“ã€‚");
      return;
    }

    state.placing.active = true;
    state.placing.type = type;
    document.getElementById('place-hint').classList.remove('hidden');
    logMessage(`è¨­ç½®ãƒ¢ãƒ¼ãƒ‰ï¼š${type === 'hospital' ? 'ğŸ¥ç—…é™¢' : type === 'police' ? 'ğŸš“è­¦å¯Ÿç½²' : 'ğŸš’æ¶ˆé˜²ç½²'}ã€‚ç½®ãå ´æ‰€ã‚’ã‚¿ãƒƒãƒ—ã—ã¦ãã ã•ã„ã€‚`);
  }

  function cancelPlacing() {
    state.placing.active = false;
    state.placing.type = null;
    document.getElementById('place-hint').classList.add('hidden');
  }

  function isRoad(x, y) { return townMap?.[y]?.[x] === TILE_ROAD; }

  function popLossByExistingBuildingId(id) {
    if (id === BLD_HUT) return POP_LOSS_BY_BUILDING.hut;
    if (id === BLD_HOUSE) return POP_LOSS_BY_BUILDING.house;
    if (id === BLD_APT) return POP_LOSS_BY_BUILDING.apt;
    if (id === BLD_BIG) return POP_LOSS_BY_BUILDING.big;
    if (id === BLD_PARK) return POP_LOSS_BY_BUILDING.park;
    if (id === BLD_TREE) return POP_LOSS_BY_BUILDING.tree;
    return 0;
  }

  function placeFacilityAt(x, y) {
    if (!state.placing.active) return;
    if (x < 0 || x >= TOWN_W || y < 0 || y >= TOWN_H) return;

    if (isRoad(x, y)) {
      logMessage("é“è·¯ã«ã¯ç½®ã‘ã¾ã›ã‚“ã€‚åˆ¥ã®ãƒã‚¹ã‚’ã‚¿ãƒƒãƒ—ã—ã¦ãã ã•ã„ã€‚");
      return;
    }

    const type = state.placing.type;
    const cost = FACILITY_COST[type] ?? 0;

    const limit = FACILITY_LIMIT[type] ?? 99;
    if (countFacility(type) >= limit) { openModal("ä¸Šé™ã«é”ã—ã¦ã„ã¾ã™ã€‚"); cancelPlacing(); return; }
    if (state.money < cost) { openModal("è³‡é‡‘ãŒè¶³ã‚Šã¾ã›ã‚“ã€‚"); cancelPlacing(); return; }

    const existing = buildingMap[y][x];
    if (existing !== BLD_EMPTY && !isFacilityTile(existing)) {
      const loss = popLossByExistingBuildingId(existing);
      state.population = Math.max(10, state.population - loss);
      logMessage(`å»ºã¦æ›¿ãˆï¼šæ—¢å­˜å»ºç‰©ãŒæ¶ˆå¤±â€¦ äººå£ -${loss}`);
    }

    const id = type === 'hospital' ? BLD_HOSPITAL : type === 'police' ? BLD_POLICE : BLD_FIRE;
    state.money -= cost;
    buildingMap[y][x] = id;

    logMessage(`${type === 'hospital' ? 'ğŸ¥ ç—…é™¢' : type === 'police' ? 'ğŸš“ è­¦å¯Ÿç½²' : 'ğŸš’ æ¶ˆé˜²ç½²'}ã‚’è¨­ç½®ã—ã¾ã—ãŸï¼`);
    cancelPlacing();
    updateUI();
  }

  canvas.addEventListener('pointerdown', (ev) => {
    if (state.uiTab !== 'town') return;
    if (state.mode !== 'town') return;
    if (!state.placing.active) return;

    const rect = canvas.getBoundingClientRect();
    const cx = ev.clientX - rect.left;
    const cy = ev.clientY - rect.top;

    const geo = getTownDrawGeo();
    if (!geo) return;
    const { ox, oy, tileDrawSize, mapWpx, mapHpx } = geo;

    if (cx < ox || cy < oy || cx >= ox + mapWpx || cy >= oy + mapHpx) return;

    const x = Math.floor((cx - ox) / tileDrawSize);
    const y = Math.floor((cy - oy) / tileDrawSize);

    placeFacilityAt(x, y);
  });

  const PLAYER_SPR = {
    get img(){ return ASSETS.player.img; },
    get ready(){ return ASSETS.player.ok; },
    cols: 5,
    frameW: 0,
    frameH: 0,
    scale: 2.8,
    flipX: true
  };

  function setupPlayerSpriteMeta() {
    if (!PLAYER_SPR.ready || !PLAYER_SPR.img) return;
    PLAYER_SPR.frameW = Math.floor(PLAYER_SPR.img.width / PLAYER_SPR.cols);
    PLAYER_SPR.frameH = PLAYER_SPR.img.height;
  }

  function drawPlayerFrame(frameIndex, x, y) {
    if (!PLAYER_SPR.ready || !PLAYER_SPR.img || !PLAYER_SPR.frameW || !PLAYER_SPR.frameH) return;
    const fw = PLAYER_SPR.frameW;
    const fh = PLAYER_SPR.frameH;
    const sx = frameIndex * fw;
    const sy = 0;
    const dw = fw * PLAYER_SPR.scale;
    const dh = fh * PLAYER_SPR.scale;

    ctx.save();
    ctx.imageSmoothingEnabled = false;
    if (PLAYER_SPR.flipX) {
      ctx.translate(x + dw, y);
      ctx.scale(-1, 1);
      ctx.drawImage(PLAYER_SPR.img, sx, sy, fw, fh, 0, 0, dw, dh);
    } else {
      ctx.drawImage(PLAYER_SPR.img, sx, sy, fw, fh, x, y, dw, dh);
    }
    ctx.restore();
  }

  const playerAnim = { walkUntil: 0, attackUntil: 0 };
  function playWalk(ms = 450)   { playerAnim.walkUntil = Date.now() + ms; }
  function playAttack(ms = 260) { playerAnim.attackUntil = Date.now() + ms; }
  function getPlayerFrame() {
    const now = Date.now();
    if (now < playerAnim.attackUntil) return 4;
    if (now < playerAnim.walkUntil) return Math.floor(now / 140) % 4;
    return 0;
  }

  const BASE_SHOP_ITEMS = [
    { id: 'tong1',  name: 'éŒ†ã³ãŸãƒˆãƒ³ã‚°', type: 'atk', val: 5,   price: 500,   req: 0,   icon: 'ğŸ¥¢', category: 'gear' },
    { id: 'glove1', name: 'è»æ‰‹',         type: 'spd', val: 3,   price: 800,   req: 100, icon: 'ğŸ§¤', category: 'gear' },
    { id: 'pad1',   name: 'é˜²è­·ãƒ‘ãƒƒãƒ‰',   type: 'def', val: 8,   price: 2500,  req: 120, icon: 'ğŸ›¡ï¸', category: 'gear' },
    { id: 'tong2',  name: 'ãƒã‚¿ãƒ³ãƒˆãƒ³ã‚°', type: 'atk', val: 15,  price: 2000,  req: 150, icon: 'ğŸ¥¢', category: 'gear' },
    { id: 'suit',   name: 'é˜²è­·ã‚¹ãƒ¼ãƒ„',   type: 'hp',  val: 250, price: 18000, req: 600, icon: 'ğŸ¥‹', category: 'gear' },

    { id: 'bag_s',  name: 'ã‚´ãƒŸè¢‹(å°)',     price: 0,     req: 0,   icon: 'ğŸ—‘ï¸', category: 'bag', cap: 100 },
    { id: 'bag_m',  name: 'ã‚´ãƒŸè¢‹(ä¸­)',     price: 900,   req: 0,   icon: 'ğŸ—‘ï¸', category: 'bag', cap: 180 },
    { id: 'bag_l',  name: 'ã‚´ãƒŸè¢‹(å¤§)',     price: 2200,  req: 50,  icon: 'ğŸ—‘ï¸', category: 'bag', cap: 260 },
    { id: 'eco',    name: 'ã‚¨ã‚³ãƒãƒƒã‚°',     price: 1500,  req: 0,   icon: 'ğŸ›ï¸', category: 'bag', cap: 140 },
    { id: 'ruck',   name: 'ãƒªãƒ¥ãƒƒã‚¯ã‚µãƒƒã‚¯', price: 4800,  req: 100, icon: 'ğŸ’', category: 'bag', cap: 220 },
    { id: 'mobile', name: 'ç§»å‹•å¼ã‚´ãƒŸç®±',   price: 12000, req: 200, icon: 'ğŸš®', category: 'bag', cap: 420 }
  ];

  const ENEMIES = [
    // enemy1
    { n: "è’ã¶ã‚‹ã‚´ãƒŸè¢‹",      h: 40,  a: 10, s: 2,  x: 25,  e: 'ğŸ—‘ï¸', imgKey: "enemy1", hpWeight: 0.35, atkWeight: 0.25 },
    // enemy2
    { n: "æ”¾ç½®ã•ã‚ŒãŸãƒ†ãƒ¬ãƒ“",  h: 120, a: 25, s: 6,  x: 90,  e: 'ğŸ“º', imgKey: "enemy2", hpWeight: 0.65, atkWeight: 0.45 },
    // enemy3
    { n: "è’ã¶ã‚‹ç©ºãç¼¶",      h: 180, a: 35, s: 8,  x: 150, e: 'ğŸ¥«', imgKey: "enemy3", hpWeight: 0.80, atkWeight: 0.55 }
  ];

  function saveGame() {
    try { localStorage.setItem('ecoTownSave', JSON.stringify(state)); }
    catch (e) { console.warn('Save failed', e); }
  }

  function loadGame() {
    try {
      const raw = localStorage.getItem('ecoTownSave');
      if (state.trust == null) state.trust = 0;
      if (!raw) return;
      const loaded = JSON.parse(raw);
      if (!loaded || !loaded.player || !loaded.stats) return;

      state = loaded;

state = loaded;

// âœ… ã“ã‚Œã‚’è¿½åŠ ï¼ˆå¤ã„ã‚»ãƒ¼ãƒ–äº’æ›ï¼‰
if (state.trust == null) state.trust = 0;
      if (!state.lastTick) state.lastTick = Date.now();
      if (!state.battle) state.battle = { isPlayerTurn: false, isAnimating: false, defending: false };
      if (!state.inventory) state.inventory = [];
      if (!state.staffCost) state.staffCost = 300;
      if (!state.loot) state.loot = { cur: 0, max: 100 };
      if (!state.player.bagId) state.player.bagId = 'bag_s';
      if (!state.lastDisasterAt) state.lastDisasterAt = 0;
      if (!state.placing) state.placing = { active: false, type: null };
      if (!state.patrol) state.patrol = { until: 0 };
      if (!state.dungeon) state.dungeon = { bossSpawned: false, bossDefeated: false, zeroUsed: false };
      if (state.dungeon.zeroUsed == null) state.dungeon.zeroUsed = false;
      if (!state.uiTab) state.uiTab = 'town';
      if (!state.mode) state.mode = 'town';

      // ãƒ¬ã‚¬ã‚·ãƒ¼ã‚»ãƒ¼ãƒ–äº’æ›: é¸æŠä¸­ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³ãŒç„¡ã„å ´åˆã¯èµ¤å¡šå…¬åœ’ã‚’ã‚»ãƒƒãƒˆ
      if (!state.selectedDungeon) state.selectedDungeon = 'akatsuka';

      // âœ… æ—§ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚»ãƒ¼ãƒ–äº’æ›: cleared ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãŒç„¡ã„å ´åˆã¯åˆæœŸåŒ–
      if (!state.cleared) {
        state.cleared = { akatsuka: false, takashimadaira: false, arakawa: false };
      } else {
        if (state.cleared.akatsuka == null) state.cleared.akatsuka = false;
        if (state.cleared.takashimadaira == null) state.cleared.takashimadaira = false;
        if (state.cleared.arakawa == null) state.cleared.arakawa = false;
      }
      // âœ… è»¢ç”Ÿå›æ•°ãŒç„¡ã„å ´åˆã¯0ã§åˆæœŸåŒ–
      if (state.reincarnations == null) state.reincarnations = 0;

      if (state.player.baseDef == null) state.player.baseDef = 0;
      if (!state.player.equip) state.player.equip = { weapon: null, hand: null, body: null };

      // âœ… å´©å£Šãƒ•ã‚§ãƒ¼ã‚ºã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè£œå®Œ
      ensureCollapseState();

      // âœ… ã‚»ãƒ¼ãƒ–ãŒã€Œé å¾ä¸­(dungeon)ã€ã‚„æˆ¦é—˜ä¸­ã®ã¾ã¾çµ‚ã‚ã£ã¦ã„ã‚‹ã¨ã€
      //    èµ·å‹•ç›´å¾Œã«ã‚¿ãƒ–ãŒãƒ­ãƒƒã‚¯ã•ã‚Œã¦è©°ã‚€ã“ã¨ãŒã‚ã‚‹ãŸã‚ã€èµ·å‹•æ™‚ã¯è¡—ã¸æˆ»ã™ã€‚
      if (state.mode !== 'town') {
        state.mode = 'town';
        state.uiTab = 'town';
      }

      // âœ… ã™ã§ã«å›å¾©æ¡ä»¶ã‚’æº€ãŸã—ã¦ã„ã‚‹ã®ã«å´©å£Šãƒ•ãƒ©ã‚°ã ã‘æ®‹ã£ã¦ã„ã‚‹å ´åˆã¯ã€
      //    èµ·å‹•ç›´å¾Œã«è§£é™¤åˆ¤å®šã‚’æ—©ã‚ã‚‹ï¼ˆäººå£ãŒå¢—ãˆãªã„/æ¸›ã‚Šç¶šã‘ã‚‹å•é¡Œã®å¯¾ç­–ï¼‰ã€‚
      if (state.collapse && state.collapse.active) {
        const recoveredNow = (state.stats.env >= 80 && state.stats.security >= 80 && state.stats.health >= 80);
        if (recoveredNow) {
          state.collapse.recoverLastAt = Date.now() - 21000; // 20ç§’ãƒ›ãƒ¼ãƒ«ãƒ‰æ¸ˆã¿æ‰±ã„
        }
        try { tryExitCollapsePhase(); } catch (e) {}
      }

      if (state._supportMigrated_v2 == null) state._supportMigrated_v2 = false;
      migrateSupportsIfNeeded();
      ensureSupportState();

      if (state.supports?.inventory?.length) {
        state.supports.inventory.forEach(u => {
          if (u.dupes == null) u.dupes = 0;
          if (u.level == null) u.level = 1;
          if (u.exp == null) u.exp = 0;
        });
      }

      ensureDefaultBagOwned();
    } catch (e) {
      console.warn('Load failed', e);
    }
  }
function addTrust(amount, reason = "") {
  const before = state.trust ?? 0;
  state.trust = clamp(before + amount, 0, 100);
  const diff = Math.round(state.trust - before);
  if (diff !== 0 && reason) logMessage(`ğŸ¤ ä¿¡é ¼ ${diff > 0 ? "+" : ""}${diff}ï¼ˆ${reason}ï¼‰`);
}
  function enableAutoSave() { setInterval(saveGame, 5000); }

  function ensureDefaultBagOwned() {
    if (!state.inventory.some(i => i.id === 'bag_s')) state.inventory.push({ id: 'bag_s', plus: 0 });
  }

  function getEquippedBag() {
    const id = state.player.bagId || 'bag_s';
    return BASE_SHOP_ITEMS.find(i => i.id === id && i.category === 'bag') || BASE_SHOP_ITEMS.find(i => i.id === 'bag_s');
  }

  function updateLootMaxFromBag() {
    ensureDefaultBagOwned();
    const bag = getEquippedBag();
    const cap = bag?.cap ?? 100;
    state.loot.max = cap;
    state.loot.cur = Math.min(state.loot.max, state.loot.cur);
  }

  function equipBag(id) {
    const item = BASE_SHOP_ITEMS.find(i => i.id === id && i.category === 'bag');
    if (!item) return;
    if (!state.inventory.some(inv => inv.id === id)) return;

    state.player.bagId = id;
    updateLootMaxFromBag();
    logMessage(`è£…å‚™å¤‰æ›´ï¼š${item.name}ï¼ˆå®¹é‡ ${item.cap}ï¼‰`);
    updateUI();
    refreshShop();
  }

  function renderShop(){ refreshShop(); }
  function updateHUD(){ updateUI(); }

  function ensureEquipState(){
    if (!state.player) state.player = {};
    if (!state.player.equip) state.player.equip = { weapon: null, hand: null, body: null };
  }

  function gearSlotOf(id){
    if (id.startsWith("tong")) return "weapon";
    if (id.startsWith("glove")) return "hand";
    if (id === "pad1") return "body";
    if (id === "suit") return "body";
    return null;
  }

  function getEquippedGearIdSet(){
    ensureEquipState();
    const e = state.player.equip;
    return new Set([e.weapon, e.hand, e.body].filter(Boolean));
  }

  function getPlayerStats() {
    ensureEquipState();

    let bonus = { atk: 0, def: 0, spd: 0, luk: 0, hp: 0 };
    const equipped = getEquippedGearIdSet();

    state.inventory.forEach(inv => {
      const base = BASE_SHOP_ITEMS.find(i => i.id === inv.id);
      if (!base) return;
      if (base.category === 'bag') return;

      if (!equipped.has(inv.id)) return;

      const mul = 1 + ((inv.plus ?? 0) * 0.2);
      if (base.type) {
        if (bonus[base.type] == null) bonus[base.type] = 0;
        bonus[base.type] += Math.floor((base.val || 0) * mul);
      }
    });

    const s = calcSupportBonus();

    return {
      atk: state.player.baseAtk + bonus.atk + s.atk,
      def: state.player.baseDef + bonus.def + s.def,
      spd: state.player.baseSpd + bonus.spd + s.spd,
      luk: state.player.baseLuk + bonus.luk,
      maxHp: state.player.maxHp + bonus.hp + s.maxHp
    };
  }

  function toggleEquipGear(id) {
    ensureEquipState();
    const slot = gearSlotOf(id);
    if (!slot) return;

    const cur = state.player.equip[slot];
    state.player.equip[slot] = (cur === id) ? null : id;

    updateEquipUI();
  }

  function updateEquipUI() {
    updateEquipTextUI();
    renderShop();
    updateHUD();
  }

  function updateEquipTextUI() {
    ensureEquipState();
    const e = state.player.equip;

    const nameOf = (id) => {
      if (!id) return "-";
      const it = BASE_SHOP_ITEMS.find(x => x.id === id);
      return it ? it.name : "-";
    };

    const w = document.getElementById("eq-weapon");
    const h = document.getElementById("eq-hand");
    const b = document.getElementById("eq-body");
    if (w) w.innerText = nameOf(e.weapon);
    if (h) h.innerText = nameOf(e.hand);
    if (b) b.innerText = nameOf(e.body);
  }

  function getTownProgressLevel() {
    if (state.population < 120) return 0;
    if (state.population < 160) return 1;
    if (state.population < 220) return 2;
    if (state.population < 300) return 3;
    return 4;
  }

  function applyTownGrowth() {
    const lv = getTownProgressLevel();

    townMap = Array.from({ length: TOWN_H }, () =>
      Array.from({ length: TOWN_W }, () => TILE_GRASS)
    );

    const midY = Math.floor(TOWN_H / 2);
    const midX = Math.floor(TOWN_W / 2);

    for (let x = 0; x < TOWN_W; x++) townMap[midY][x] = TILE_ROAD;

    if (lv >= 1) for (let y = 0; y < TOWN_H; y++) townMap[y][midX] = TILE_ROAD;

    if (lv >= 2) {
      const x1 = Math.max(1, midX - 4);
      const x2 = Math.min(TOWN_W - 2, midX + 4);
      for (let y = 0; y < TOWN_H; y++) {
        townMap[y][x1] = TILE_ROAD;
        townMap[y][x2] = TILE_ROAD;
      }
    }

    if (lv >= 3) {
      const y1 = Math.max(1, midY - 2);
      const y2 = Math.min(TOWN_H - 2, midY + 2);
      for (let x = 0; x < TOWN_W; x++) {
        townMap[y1][x] = TILE_ROAD;
        townMap[y2][x] = TILE_ROAD;
      }
    }

    if (lv >= 4) {
      townMap[1][1] = TILE_ROAD;
      townMap[1][TOWN_W - 2] = TILE_ROAD;
      townMap[TOWN_H - 2][1] = TILE_ROAD;
      townMap[TOWN_H - 2][TOWN_W - 2] = TILE_ROAD;
    }

    applyBuildingGrowth();
  }

  function neighborsAreRoad(x, y) {
    const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
    return dirs.some(([dx,dy]) => {
      const nx = x + dx, ny = y + dy;
      if (nx < 0 || nx >= TOWN_W || ny < 0 || ny >= TOWN_H) return false;
      return townMap[ny][nx] === TILE_ROAD;
    });
  }

  function getBuildingTierByPop(pop) {
    if (pop < 140) return 0;
    if (pop < 220) return 1;
    if (pop < 320) return 2;
    return 3;
  }

  function pickBuildingForTier(tier) {
    const r = Math.random();
    if (tier === 0) return BLD_HUT;
    if (tier === 1) return (r < 0.75) ? BLD_HOUSE : BLD_APT;
    if (tier === 2) {
      if (r < 0.15) return BLD_HOUSE;
      if (r < 0.80) return BLD_APT;
      return BLD_BIG;
    }
    if (r < 0.25) return BLD_HOUSE;
    if (r < 0.70) return BLD_APT;
    return BLD_BIG;
  }

  function applyBuildingGrowth() {
    for (let y = 0; y < TOWN_H; y++) for (let x = 0; x < TOWN_W; x++) {
      if (townMap[y][x] === TILE_ROAD && !isFacilityTile(buildingMap[y][x])) buildingMap[y][x] = BLD_EMPTY;
    }

    const tier = getBuildingTierByPop(state.population);
    const targetBuildings = Math.min((tier + 1) * 10, Math.floor(state.population / 25));

    let current = 0;
    for (let y = 0; y < TOWN_H; y++) for (let x = 0; x < TOWN_W; x++) {
      if (townMap[y][x] !== TILE_ROAD && buildingMap[y][x] !== BLD_EMPTY && !isFacilityTile(buildingMap[y][x])) current++;
    }

    if (current < targetBuildings) {
      const need = targetBuildings - current;
      let placed = 0;

      const candidatesNearRoad = [];
      const candidatesAny = [];
      for (let y = 0; y < TOWN_H; y++) for (let x = 0; x < TOWN_W; x++) {
        if (townMap[y][x] === TILE_ROAD) continue;
        if (buildingMap[y][x] !== BLD_EMPTY) continue;
        (neighborsAreRoad(x,y) ? candidatesNearRoad : candidatesAny).push([x,y]);
      }

      function pick(list) {
        if (list.length === 0) return null;
        const i = Math.floor(Math.random() * list.length);
        return list.splice(i,1)[0];
      }

      while (placed < need) {
        const pos = pick(candidatesNearRoad) || pick(candidatesAny);
        if (!pos) break;
        const [x,y] = pos;

        const env = state.stats.env;
        const roll = Math.random();

        if (env >= 85 && roll < 0.12) {
          buildingMap[y][x] = (Math.random() < 0.5) ? BLD_TREE : BLD_PARK;
        } else {
          buildingMap[y][x] = pickBuildingForTier(tier);
        }
        placed++;
      }
    }

    if (current > targetBuildings + 4) {
      const removeCount = Math.min(3, current - targetBuildings);
      let removed = 0;
      for (let tries = 0; tries < 200 && removed < removeCount; tries++) {
        const x = Math.floor(Math.random() * TOWN_W);
        const y = Math.floor(Math.random() * TOWN_H);
        if (townMap[y][x] === TILE_ROAD) continue;
        if (buildingMap[y][x] === BLD_EMPTY) continue;
        if (isFacilityTile(buildingMap[y][x])) continue;

        if (buildingMap[y][x] === BLD_TREE && Math.random() < 0.7) continue;
        buildingMap[y][x] = BLD_EMPTY;
        removed++;
      }
    }
  }

  function getTownDrawGeo() {
    const padding = 8;
    const usableW = canvas.width - padding * 2;
    const usableH = canvas.height - padding * 2;

    const tileDrawSize = Math.floor(Math.min(usableW / TOWN_W, usableH / TOWN_H));
    if (tileDrawSize <= 0) return null;

    const mapWpx = tileDrawSize * TOWN_W;
    const mapHpx = tileDrawSize * TOWN_H;

    const ox = Math.floor((canvas.width - mapWpx) / 2);
    const oy = Math.floor((canvas.height - mapHpx) / 2);
    return { ox, oy, tileDrawSize, mapWpx, mapHpx };
  }

  function drawTownTiles() {
    const geo = getTownDrawGeo();
    if (!geo) return;
    const { ox, oy, tileDrawSize } = geo;

    for (let y = 0; y < TOWN_H; y++) {
      for (let x = 0; x < TOWN_W; x++) {
        const t = townMap[y][x];
        const dx = ox + x * tileDrawSize;
        const dy = oy + y * tileDrawSize;

        if (t === TILE_ROAD) {
          drawTileSheet(ROAD_TILES, 1, dx, dy, tileDrawSize, tileDrawSize, "#2a2a2a");
        } else {
          ctx.fillStyle = "#173a1d";
          ctx.fillRect(dx, dy, tileDrawSize, tileDrawSize);
        }

        const b = buildingMap[y][x];
        if (t !== TILE_ROAD && b !== BLD_EMPTY) {
          if (isFacilityTile(b)) {
            const civicId = civicTileIdOfBuildingId(b);
            drawTileSheet(CIVIC_TILES, civicId, dx, dy, tileDrawSize, tileDrawSize, "#444");
          } else {
            drawTileSheet(BUILD_TILES, b, dx, dy, tileDrawSize, tileDrawSize, "#444");
          }

          if (infected[y][x] > 0) {
            ctx.save();
            ctx.globalAlpha = 0.85;
            ctx.font = `${Math.floor(tileDrawSize * 0.9)}px 'DotGothic16', monospace`;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText("â˜£", dx + tileDrawSize / 2, dy + tileDrawSize / 2);
            ctx.restore();
          }
        }
      }
    }
  }

  function waste01() {
    const wr = state?.wasteRate ?? 0;
    return clamp(wr / ENEMY_WASTE_SCALE_MAX, 0, 1);
  }
  function getEnemyBoost(enemyBase) {
    const w = waste01();
    const hpBoost  = 1 + (ENEMY_HP_BOOST_MAX  * w * (enemyBase.hpWeight ?? 0.55));
    const atkBoost = 1 + (ENEMY_ATK_BOOST_MAX * w * (enemyBase.atkWeight ?? 0.35));
    return { w, hpBoost, atkBoost };
  }
  function spawnEnemy(enemyBase) {
    const boost = getEnemyBoost(enemyBase);
    const maxH = Math.max(1, Math.floor(enemyBase.h * boost.hpBoost));
    const a    = Math.max(1, Math.floor(enemyBase.a * boost.atkBoost));
    return { ...enemyBase, maxH, curH: maxH, a, boost };
  }

  function getEnvBarrierRate() {
    const units = getEquippedSupports();
    const mirako = units.find(u => u.masterId === "mirako");
    if (!mirako) return 0;
    const r = mirako.rarity ?? 1;
    if (r === 1) return 0.10;
    if (r === 2) return 0.15;
    if (r === 3) return 0.20;
    if (r === 4) return 0.30;
    if (r >= 5) return 0.40;
    return 0;
  }

  function simulateCityTick({ isOffline = false } = {}) {
    const eff = getFacilityEffects();
    const envBarrier = getEnvBarrierRate();

    state.wasteRate += state.population / 400;

    let clean = state.staff * 0.9;
    if (!isOffline && state.mode !== 'town') clean *= 2.0;
    state.wasteRate = Math.max(0, state.wasteRate - clean);

    if (state.wasteRate > 5.0) state.stats.env -= 0.5 * (1 - envBarrier);
    else if (state.wasteRate < 1.0) state.stats.env += 0.3;

    if (state.wasteRate > 4.0) {
      state.stats.security -= 0.35;
      state.stats.health   -= 0.25;
    } else if (state.wasteRate < 1.2) {
      state.stats.security += 0.15;
      state.stats.health   += 0.15;
    }

    state.stats.security += eff.securityRegen;

    // âœ… ãƒ‘ãƒˆãƒ­ãƒ¼ãƒ«ä¸­ã¯æ²»å®‰å›å¾©ãŒå¢—ãˆã‚‹
    if (isPatrolActive()) {
      state.stats.security += PATROL_REGEN_BONUS;
    }

    state.stats.health += eff.healthRegen;

    if (state.wasteRate > 12) state.population = Math.max(10, state.population - 4);
    else if (state.wasteRate > 6) state.population = Math.max(10, state.population - 2);

    if (state.stats.env > 80) state.population += Math.floor(state.population * 0.01) + 1;
    else if (state.stats.env < 40) state.population = Math.max(10, state.population - 2);

    let incomeMul = 1.0;
    if (state.stats.security < 40) incomeMul *= 0.8;
    if (state.stats.health   < 40) incomeMul *= 0.85;
    state.money += Math.floor(state.population * 0.2 * incomeMul);

    Object.keys(state.stats).forEach(k => state.stats[k] = clamp(state.stats[k], 0, 100));

    for (let y = 0; y < TOWN_H; y++) for (let x = 0; x < TOWN_W; x++) {
      if (infected[y][x] > 0) infected[y][x] = Math.max(0, infected[y][x] - 1);
    }
  }

  function applyOfflineProgress() {
    const now  = Date.now();
    const last = state.lastTick || now;
    let diffSec = Math.floor((now - last) / 1000);
    diffSec = Math.max(0, Math.min(diffSec, 12 * 60 * 60));
    for (let i = 0; i < diffSec; i++) {
      simulateCityTick({ isOffline: true });
      applyTownGrowth();
    }
    state.lastTick = now;
  }

  function mainLoopTick() {
    simulateCityTick({ isOffline: false });

    // âœ… å´©å£Šãƒ•ã‚§ãƒ¼ã‚ºï¼šåˆ¤å®šï¼†å´©å£Šä¸­å‡¦ç†ï¼ˆæ¯ç§’ï¼‰
    checkCollapseTriggers();
    applyCollapseTick();

    state.lastTick = Date.now();
    applyTownGrowth();
    updateUI();
    if (document.getElementById('tab-shop')?.classList.contains('active')) refreshShop();
  }

  function updateUI() {
    ensureSupportState();
    ensureCollapseState();
    // âœ… ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³ãƒœã‚¿ãƒ³ã®è¡¨ç¤ºçŠ¶æ…‹ã‚’æ›´æ–°
    if (typeof updateDungeonButtons === 'function') {
      try { updateDungeonButtons(); } catch (e) { console.warn(e); }
    }
    updateLootMaxFromBag();
    updateAssetStatus();
    updateEquipTextUI();

    // âœ… æˆ¦é—˜ä¸­ãƒ»é å¾ä¸­ã¯ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³é¸æŠã‚¨ãƒªã‚¢ã‚’éš ã™ï¼ˆè¡¨ç¤ºæ¼ã‚Œå¯¾ç­–ï¼‰
    const ds = document.getElementById('dungeon-select');
    if (ds) ds.style.display = (state.mode === 'battle' || state.mode === 'dungeon') ? 'none' : '';

    const ps = getPlayerStats();
    state.player.hp = clamp(state.player.hp, 0, ps.maxHp);

    document.getElementById('ui-money').innerText = Math.floor(state.money).toLocaleString();
    document.getElementById('ui-pop').innerText   = Math.floor(state.population);
    document.getElementById('ui-waste').innerText = state.wasteRate.toFixed(1);

    document.getElementById('bar-env').style.width  = `${state.stats.env}%`;
    document.getElementById('bar-sec').style.width  = `${state.stats.security}%`;
    document.getElementById('bar-heal').style.width = `${state.stats.health}%`;

    document.getElementById('val-env').innerText  = Math.floor(state.stats.env);
    document.getElementById('val-sec').innerText  = Math.floor(state.stats.security);
    document.getElementById('val-heal').innerText = Math.floor(state.stats.health);
    // âœ… ä¿¡é ¼ã‚²ãƒ¼ã‚¸UIæ›´æ–°ï¼ˆä¸Šé™ã¯ state.trustMax ã‚’ä½¿ç”¨ï¼‰
    const maxTrust = (state.trustMax ?? 100);
    const trust = clamp(state.trust ?? 0, 0, maxTrust);
    const vt = document.getElementById("val-trust");
    const bt = document.getElementById("bar-trust");
    if (vt) vt.innerText = Math.floor(trust);
    if (bt) {
      // ã‚²ãƒ¼ã‚¸ã¯ä¿¡é ¼å€¤ã‚’ä¸Šé™ã«å¯¾ã™ã‚‹å‰²åˆã§å¹…ã‚’æ±ºå®š
      const ratio = maxTrust > 0 ? (trust / maxTrust) * 100 : 0;
      bt.style.width = `${ratio}%`;
    }
    document.getElementById('st-atk').innerText = ps.atk;
    document.getElementById('st-def').innerText = ps.def;
    document.getElementById('st-spd').innerText = ps.spd;
    document.getElementById('st-luk').innerText = ps.luk;

    const hpPercent = ps.maxHp > 0 ? (state.player.hp / ps.maxHp) * 100 : 0;
    document.getElementById('ui-hp-text').innerText = `${Math.ceil(state.player.hp)}/${ps.maxHp}`;
    document.getElementById('hp-bar').style.width   = `${hpPercent}%`;

    document.getElementById('battle-player-hp-bar').style.width = `${hpPercent}%`;
    document.getElementById('battle-player-hp-text').innerText  = `${Math.ceil(state.player.hp)}/${ps.maxHp}`;

    document.getElementById('ui-lv').innerText = state.player.lv;
    document.getElementById('ui-xp').innerText = Math.max(0, state.player.next - state.player.xp);

    const btnDrink = document.getElementById('btn-drink');
    if (btnDrink) btnDrink.innerText = `ğŸ§ª ãƒœãƒˆãƒ«(${state.player.drinks})`;

    document.getElementById('staff-cost').innerText = `${state.staffCost}G`;

    document.getElementById('ui-clean').innerText = (state.staff * 0.9).toFixed(1);
    document.getElementById('ui-staff').innerText = state.staff;

    const lootCur = state.loot?.cur ?? 0;
    const lootMax = state.loot?.max ?? 100;
    const lootPct = lootMax > 0 ? (lootCur / lootMax) * 100 : 0;
    document.getElementById('ui-loot').innerText = Math.floor(lootCur);
    document.getElementById('ui-loot-max').innerText = Math.floor(lootMax);
    document.getElementById('loot-bar').style.width = `${clamp(lootPct,0,100)}%`;

    const bag = getEquippedBag();
    document.getElementById('ui-bag-name').innerText = bag ? `${bag.name}ï¼ˆ${bag.cap}ï¼‰` : '-';

    document.getElementById('place-hint').classList.toggle('hidden', !state.placing.active);

    const enemyHpText = document.getElementById('enemy-hp-text');
    if (enemyHpText) {
      if (state.mode === 'battle' && state.enemy) {
        enemyHpText.innerText = `${Math.max(0, Math.ceil(state.enemy.curH))}/${Math.max(1, Math.ceil(state.enemy.maxH))}`;
      } else {
        enemyHpText.innerText = `0/0`;
      }
    }

    // å´©å£Šæ¼”å‡ºã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã®è‡ªç„¶æ¶ˆç¯
    tickCollapseOverlay();
    
   // âœ… å›½æ°‘ç·æ”¯æ´ãƒœã‚¿ãƒ³ï¼šä½¿ç”¨å¯èƒ½ã«ãªã£ãŸã‚‰ã€Œã†ã£ã™ã‚‰ç‚¹æ»…ã€
const ns = document.getElementById("btn-national-support");
if (ns) {
  const collapseActive = !!state.collapse?.active;

  // useNationalSupport() å†…ã§ä½¿ã£ã¦ã‚‹ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ã«åˆã‚ã›ã‚‹
  const now = Date.now();
  const cdUntil = state._nationalSupportCdUntil || 0;
  const cooldown = now < cdUntil;

  // âœ… ã€Œä½¿ç”¨ã§ãã‚‹æ¡ä»¶ã€ï¼šå´©å£Šä¸­ ã‹ã¤ ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ä¸­ã˜ã‚ƒãªã„
  const canUse = collapseActive && !cooldown;

  // ã¾ãšã‚¢ãƒ‹ãƒ¡ã‚¯ãƒ©ã‚¹ã‚’ãƒªã‚»ãƒƒãƒˆ
  ns.classList.remove("pulse-available");

  if (!collapseActive) {
    // å´©å£Šä¸­ã˜ã‚ƒãªã„ï¼šç„¡åŠ¹è¡¨ç¤º
    ns.style.opacity = "0.35";
    ns.style.filter = "grayscale(1)";
    ns.style.cursor = "not-allowed";
    ns.innerText = "ğŸ› å›½æ°‘ç·æ”¯æ´ï¼ˆå´©å£Šä¸­ã®ã¿ï¼‰";
  } else if (cooldown) {
    // å´©å£Šä¸­ã ã‘ã©ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ï¼šç‚¹æ»…ã¯ã•ã›ãªã„ï¼ˆæº–å‚™ä¸­ï¼‰
    const left = Math.ceil((cdUntil - now) / 1000);
    ns.style.opacity = "0.55";
    ns.style.filter = "grayscale(0)";
    ns.style.cursor = "not-allowed";
    ns.innerText = `ğŸ› å›½æ°‘ç·æ”¯æ´ï¼ˆæº–å‚™ä¸­â€¦ ${left}sï¼‰`;
  } else {
    // âœ… ä½¿ç”¨å¯èƒ½ï¼šã†ã£ã™ã‚‰ç‚¹æ»…ã§ã€Œä½¿ãˆã‚‹ã‚ˆã€æ¼”å‡º
    ns.style.opacity = "1";
    ns.style.filter = "none";
    ns.style.cursor = "pointer";
    ns.classList.add("pulse-available");
    ns.innerText = "ğŸ› å›½æ°‘ç·æ”¯æ´ï¼ˆå´©å£ŠæŠ‘åˆ¶ï¼‰";
  }
}    setActiveNav(state.uiTab);
  }

  function setActiveNav(tab) {
    const ids = ["town","shop","explore"];
    for (const t of ids) {
      const btn = document.getElementById("nav-"+t);
      if (!btn) continue;
      btn.classList.toggle("bg-gray-200", tab === t);
    }
  }

  function showTab(t) {
    if (state.mode !== 'town' && t !== 'explore') {
      logMessage("é å¾ä¸­ã¯è¡—/åº—ã«æˆ»ã‚Œã¾ã›ã‚“ã€‚ã€æ’¤é€€ã€ã—ã¦ãã ã•ã„ã€‚");
      return;
    }

    if (t !== 'town') cancelPlacing();

    state.uiTab = t;

    document.querySelectorAll('.tab-content').forEach(el => el.classList.remove('active'));
    document.getElementById('tab-' + t).classList.add('active');

    if (t === 'shop') refreshShop();
    updateUI();
  }

  function applyMirakoDrinkBonusOnStart() {
    const units = getEquippedSupports();
    const mirako = units.find(u => u.masterId === "mirako");
    if (!mirako) return;
    const r = mirako.rarity ?? 1;
    if (r < 4) return;

    const add = (r >= 5) ? 2 : 1;
    state.player.drinks = Math.min(5, (state.player.drinks ?? 0) + add);
    logMessage(`ğŸŒ¸ å›å¾©ã®å¿œæ´ãƒ‰ãƒªãƒ³ã‚¯ï¼ ãƒœãƒˆãƒ« +${add}ï¼ˆæœ€å¤§5ï¼‰`);
  }

  function startDungeon() {
    cancelPlacing();
    state.mode = 'dungeon';
    state.uiTab = 'explore';

    // ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³é€²è¡ŒçŠ¶æ…‹ã‚’åˆæœŸåŒ–ï¼ˆé¸æŠä¸­ã¯ä¿æŒï¼‰
    state.distance = 0;
    state.loot.cur = 0;
    state.dungeon = { bossSpawned: false, bossDefeated: false, zeroUsed: false };

    applyMirakoDrinkBonusOnStart();

    // UIåˆ‡ã‚Šæ›¿ãˆ
    document.getElementById('ui-town-ctrl').classList.add('hidden');
    document.getElementById('ui-dungeon-ctrl').classList.remove('hidden');
    document.getElementById('ui-battle-ctrl').classList.add('hidden');
    document.getElementById('battle-hud').classList.add('hidden');

    // æ­©è¡Œã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã¨æ¢ç´¢ãƒ­ã‚°
    playWalk(650);
    const d = DUNGEONS[state.selectedDungeon] || DUNGEONS.akatsuka;
    logMessage(`${d.name} ã®æ¢ç´¢ã‚’é–‹å§‹ã—ãŸã€‚`);
    showTab('explore');
    updateUI();
  }

  function tryFromZeroRescueAndReturn() {
    const units = getEquippedSupports();
    const fz = units.find(u => u.masterId === "fromzero");
    const can = fz && (fz.rarity ?? 1) >= 4 && !(state.dungeon?.zeroUsed);

    if (!can) return false;

    state.dungeon.zeroUsed = true;
    state.player.hp = 1;
    state.loot.cur = 0;
    logMessage("ğŸ§¹ ã‚¼ãƒ­ã‹ã‚‰ã®ã‚¹ã‚¿ãƒ¼ãƒˆï¼ HP1ã§è¸ã¿ã¨ã©ã¾ã‚Šã€æˆ¦åˆ©å“0ã§å¸°é‚„ï¼");
    returnTown(true);
    updateUI();
    return true;
  }

  function dungeonStep() {
    state.distance++;
    state.player.hp -= 1;

    if (!state.dungeon.bossDefeated && !state.dungeon.bossSpawned && state.distance >= BOSS_DISTANCE_STEP) {
      logMessage("ğŸš¨ 200måˆ°é”â€¦æ•‘æ¸ˆãƒœã‚¹ãŒå‡ºç¾ã—ãŸï¼");
      startBattle({ isBoss: true });
      updateUI();
      return;
    }

    const gain = 6 + Math.floor(Math.random() * 8);
    state.loot.cur = Math.min(state.loot.max, state.loot.cur + gain);

    playWalk(450);

    if (Math.random() < 0.3) startBattle();
    else logMessage(`${state.distance}0m åœ°ç‚¹ã€‚ç•°å¸¸ãªã—ã€‚`);

    if (state.player.hp <= 0) {
      if (tryFromZeroRescueAndReturn()) return;
      openModal("é å¾å¤±æ•—ï¼è³‡é‡‘ã®ä¸€éƒ¨ã‚’å¤±ã„ã¾ã—ãŸã€‚ï¼ˆå›åã‚‚å¤±ã„ã¾ã™ï¼‰");
      state.money = Math.floor(state.money * 0.8);
      state.loot.cur = 0;
      state.player.hp = getPlayerStats().maxHp;
      returnTown(true);
      return;
    }

    updateUI();
  }

  function startBattle({ isBoss = false } = {}) {
    state.mode = 'battle';

    let base;
    if (isBoss) {
      // é¸æŠä¸­ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³ã®ãƒœã‚¹ã‚’å–å¾—ï¼ˆå­˜åœ¨ã—ãªã‘ã‚Œã°æ—¢å®šã®BOSSï¼‰
      base = DUNGEONS[state.selectedDungeon]?.boss || BOSS;
      state.dungeon.bossSpawned = true;
    } else {
      // âœ… ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³ã”ã¨ã«å‡ºç¾ã™ã‚‹ã‚¶ã‚³æ•µã‚’å›ºå®š
      const poolMap = {
        akatsuka: [0, 1],          // è’ã¶ã‚‹ã‚´ãƒŸè¢‹ / æ”¾ç½®ãƒ†ãƒ¬ãƒ“
        takashimadaira: [0, 2],    // è’ã¶ã‚‹ã‚´ãƒŸè¢‹ / è’ã¶ã‚‹ç©ºãç¼¶
        arakawa: [1, 2],           // æ”¾ç½®ãƒ†ãƒ¬ãƒ“ / è’ã¶ã‚‹ç©ºãç¼¶ï¼ˆä»®ï¼‰
        national: [2, 1]           // è’ã¶ã‚‹ç©ºãç¼¶ / æ”¾ç½®ãƒ†ãƒ¬ãƒ“ï¼ˆä»®ï¼‰
      };
      const idxs = poolMap[state.selectedDungeon] || [0, 1, 2];
      const pick = idxs[Math.floor(Math.random() * idxs.length)];
      base = ENEMIES[pick];

      // âœ… é«˜å³¶å¹³ã¯èµ¤å¡šå…¬åœ’ã®1.5å€ç›¸å½“
      const mul = (state.selectedDungeon === 'takashimadaira') ? 1.5 : 1.0;
      if (mul !== 1.0) {
        base = {
          ...base,
          h: Math.floor(base.h * mul),
          a: Math.floor(base.a * mul),
          x: Math.floor(base.x * mul)
        };
      }
    }

    state.enemy = spawnEnemy(base);
    state.enemy.isBoss = isBoss;

    // æˆ¦é—˜é–‹å§‹æ™‚ã«è«¦ã‚ãªã„æ„æ€ãƒãƒ•ã®çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
    if (!state.battle) state.battle = { isPlayerTurn: false, isAnimating: false, defending: false };
    state.battle.unwavering = { turnsLeft: 0, cooldownLeft: 0 };

    document.getElementById('ui-dungeon-ctrl').classList.add('hidden');
    document.getElementById('ui-battle-ctrl').classList.remove('hidden');
    document.getElementById('battle-hud').classList.remove('hidden');

    const w = state.enemy.boost?.w ?? 0;
    const suffix = isBoss ? "ï¼ˆæ•‘æ¸ˆãƒœã‚¹ï¼‰" : (w >= 0.8 ? "ï¼ˆçŒ›æ¯’æ±šæŸ“ï¼‰" : w >= 0.5 ? "ï¼ˆæ±šæŸ“ï¼‰" : w >= 0.25 ? "ï¼ˆè»½æ±šæŸ“ï¼‰" : "");
    document.getElementById('enemy-name').innerText = `${isBoss ? "BOSSï¼š" : ""}${state.enemy.n}${suffix}`;

    const hpBar = document.getElementById('enemy-hp-bar');
    hpBar.style.transition = 'none';
    hpBar.style.width = '100%';
    hpBar.offsetHeight;
    hpBar.style.transition = '';

    const ps = getPlayerStats();
    if (ps.spd >= state.enemy.s) {
      state.battle.isPlayerTurn = true;
      logMessage(isBoss ? "ãƒœã‚¹æˆ¦ï¼ã‚ãªãŸã®å…ˆåˆ¶æ”»æ’ƒï¼" : "ã‚ãªãŸã®å…ˆåˆ¶æ”»æ’ƒï¼");
    } else {
      state.battle.isPlayerTurn = false;
      setTimeout(enemyTurn, 800);
    }

    updateUI();
  }

  function battleTurn(action) {
    if (state.mode !== 'battle') return;
    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¿ãƒ¼ãƒ³é–‹å§‹æ™‚ï¼šè«¦ã‚ãªã„æ„æ€ãƒãƒ•ã®åŠ¹æœãƒ»ã‚¯ãƒ¼ãƒ«ã‚¿ã‚¤ãƒ å‡¦ç†
    try {
      tickUnwaveringBuff();
    } catch(e) {}
    if (!state.battle.isPlayerTurn || state.battle.isAnimating) return;

    const ps = getPlayerStats();

    if (action === 'attack') {
      playAttack(300);

      const cc = critChance(ps.luk);
      const isCrit = Math.random() < cc;
      const dmg = isCrit ? Math.floor(ps.atk * 1.6) : ps.atk;

      state.enemy.curH -= dmg;
      createFloatingText(isCrit ? `CRIT! -${dmg}` : `-${dmg}`, "#fff", 60);
      logMessage(isCrit ? `${state.enemy.n}ã«ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ï¼` : `${state.enemy.n}ã«ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼`);
    } else if (action === 'defend') {
      state.battle.defending = true;
      logMessage("èº«ã‚’è­·ã£ã¦ã„ã‚‹...ï¼ˆæ¬¡ã®è¢«ãƒ€ãƒ¡è»½æ¸›UPï¼‰");
    } else if (action === 'heal') {
      if (state.player.drinks > 0) {
        state.player.drinks--;
        state.player.hp = Math.min(ps.maxHp, state.player.hp + 100);
        logMessage("ãƒœãƒˆãƒ«ã§å›å¾©ã—ãŸï¼");
      } else {
        logMessage("ãƒœãƒˆãƒ«ãŒãªã„ï¼");
        return;
      }
    } else if (action === 'flee') {
      if (Math.random() < 0.5) { endBattle({ won: false }); return; }
      logMessage("é€ƒã’ã‚‰ã‚Œãªã‹ã£ãŸï¼");
    }

    state.enemy.curH = Math.max(0, state.enemy.curH);
    document.getElementById('enemy-hp-bar').style.width = `${(state.enemy.curH / state.enemy.maxH) * 100}%`;

    if (state.enemy.curH <= 0) {
      const lootBonus = Math.floor(ps.atk * 0.05) + Math.floor(ps.luk * 0.2);
      const lootReward = Math.floor(state.enemy.maxH * 0.8 + (Math.random() * 8)) + lootBonus;

      gainXp(state.enemy.x);
      endBattle({ won: true, lootReward, isBoss: !!state.enemy?.isBoss });
    } else {
      state.battle.isPlayerTurn = false;
      setTimeout(enemyTurn, 800);
    }

    updateUI();
  }

  function enemyTurn() {
    if (state.mode !== 'battle') return;

    const ps = getPlayerStats();

    const dc = dodgeChance(ps.spd, state.enemy.s);
    if (Math.random() < dc) {
      createFloatingText("MISS!", "#6ee7b7", 40);
      logMessage(`${state.enemy.n}ã®æ”»æ’ƒï¼â€¦ã—ã‹ã—é¿ã‘ãŸï¼`);
      state.battle.isPlayerTurn = true;
      updateUI();
      return;
    }

    const raw = state.enemy.a;
    const effDef = state.battle.defending ? ps.def * 2 : ps.def;
    const dmg = reduceDamage(raw, effDef);

    state.battle.defending = false;
    state.player.hp -= dmg;

    createFloatingText(`-${dmg}`, "#f00", 40);
    logMessage(`${state.enemy.n}ã®æ”»æ’ƒï¼`);

    if (state.player.hp <= 0) {
      if (tryFromZeroRescueAndReturn()) return;
      openModal("é å¾å¤±æ•—ï¼è³‡é‡‘ã®ä¸€éƒ¨ã‚’å¤±ã„ã¾ã—ãŸã€‚ï¼ˆå›åã‚‚å¤±ã„ã¾ã™ï¼‰");
      state.money = Math.floor(state.money * 0.8);
      state.loot.cur = 0;
      state.player.hp = getPlayerStats().maxHp;
      returnTown(true);
      return;
    }

    state.battle.isPlayerTurn = true;
    updateUI();
  }

  function animateLootGain(amount, duration = 900) {
    const from = Number(state.loot.cur || 0);
    const to = Math.min(state.loot.max, from + amount);
    const start = performance.now();

    function step(now) {
      const t = Math.min(1, (now - start) / duration);
      state.loot.cur = from + (to - from) * t;
      updateUI();
      if (t < 1) requestAnimationFrame(step);
      else { state.loot.cur = to; updateUI(); }
    }
    requestAnimationFrame(step);
  }

  function endBattle(result = { won: false, lootReward: 0, isBoss: false }) {
    if (result.won && result.isBoss) {
      document.getElementById('ui-battle-ctrl').classList.add('hidden');
      document.getElementById('battle-hud').classList.add('hidden');

      if (result.lootReward > 0) {
        logMessage(`ãƒœã‚¹æ’ƒç ´ï¼å›åï¼ +${result.lootReward}`);
        animateLootGain(result.lootReward, 900);
      } else {
        logMessage("ãƒœã‚¹æ’ƒç ´ï¼");
      }

      // å„ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³ã”ã¨ã®ãƒœã‚¹æ’ƒç ´ã«ã‚ˆã‚‹ã‚´ãƒŸå‰Šæ¸›ç‡ã‚’åˆ¤å®š
      let reduceRate = BOSS_WASTE_REDUCE_RATE;
      if (state.selectedDungeon === 'takashimadaira') reduceRate = 0.50; // é«˜å³¶å¹³ã¯50%å‰Šæ¸›
      else if (state.selectedDungeon === 'akatsuka') reduceRate = 0.30;
      // ä»Šå¾Œä»–ã®ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³ã«å¿œã˜ã¦è¨­å®šå¯èƒ½
      const before = state.wasteRate;
      state.wasteRate = Math.max(0, state.wasteRate * (1 - reduceRate));
      const reduced = before - state.wasteRate;

      state.dungeon.bossDefeated = true;

      // âœ… ãƒœã‚¹æ’ƒç ´æ™‚ã«ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³ã‚¯ãƒªã‚¢ã‚’è¨˜éŒ²
      if (state.selectedDungeon && state.cleared && Object.prototype.hasOwnProperty.call(state.cleared, state.selectedDungeon)) {
        state.cleared[state.selectedDungeon] = true;
      }

      // âœ… åˆå›ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«æ‰±ã„ï¼šæ•‘æ¸ˆãƒœã‚¹æ’ƒç ´ = tutorialBossDefeated
      ensureCollapseState();
      if (!state.collapse.enteredOnce) {
        state.collapse.tutorialBossDefeated = true;
      }

      state.enemy = null;

      setTimeout(() => {
        logMessage(`ğŸ‘‘ æ•‘æ¸ˆç™ºå‹•ï¼šè¡—ã®ã‚´ãƒŸ -30%ï¼ˆ-${reduced.toFixed(1)}ï¼‰â†’ å¼·åˆ¶å¸°é‚„`);
        returnTown(false);
        updateUI();
      }, 650);

      return;
    }

    state.mode = 'dungeon';
    document.getElementById('ui-battle-ctrl').classList.add('hidden');
    document.getElementById('ui-dungeon-ctrl').classList.remove('hidden');
    document.getElementById('battle-hud').classList.add('hidden');

    if (result.won && result.lootReward > 0) {
      logMessage(`æˆ¦é—˜çµ‚äº†ã€‚å›åï¼ +${result.lootReward}`);
      animateLootGain(result.lootReward, 900);
    } else {
      logMessage("æˆ¦é—˜çµ‚äº†ã€‚æ¢ç´¢ã‚’å†é–‹ã—ã¾ã™ã€‚");
    }

    state.enemy = null;
    playWalk(650);
    updateUI();
  }

  function gainXp(amt) {
    state.player.xp += amt;
    if (state.player.xp >= state.player.next) {
      state.player.lv++;
      state.player.xp = 0;
      state.player.next = Math.floor(state.player.next * 1.5);

      state.player.maxHp += 20;
      state.player.baseAtk += 5;
      state.player.baseDef += 3;
      state.player.baseSpd += 1;
      state.player.baseLuk += 1;

      state.player.hp = getPlayerStats().maxHp;
      openModal(`LEVEL UP! LV.${state.player.lv}ã«ãªã£ãŸï¼\nATK+5 DEF+3 SPD+1 LUK+1 HP+20`);
    }
  }

  function applyReturnCleanup(lootAmount) {
    const reduced = lootAmount * CITY_WASTE_REDUCTION_PER_LOOT;
    state.wasteRate = Math.max(0, state.wasteRate - reduced);
    return reduced;
  }

  function returnTown(isForced = false) {
  let lootAmount = 0; // âœ… å…ˆã«å®šç¾©

  if (!isForced && state.loot && state.loot.cur > 0) {
    lootAmount = Math.floor(state.loot.cur);

    const reward = Math.floor(lootAmount * MONEY_PER_LOOT);
    state.money += reward;

    const reduced = applyReturnCleanup(lootAmount);
    logMessage(`å¸°é‚„ï¼šæ›é‡‘ +${reward}G / è¡—ã®ã‚´ãƒŸ -${reduced.toFixed(1)}`);
    state.loot.cur = 0;

    // âœ… æˆæœãŒå‡ºãŸã‚‰ä¿¡é ¼UPï¼ˆå›åé‡ã«æ¯”ä¾‹ï¼‰
    addTrust(Math.min(6, Math.floor(lootAmount / 60) + 1), "æ¸…æƒã®æˆæœ");

  } else {
    state.loot.cur = 0;
    logMessage("æ’¤é€€ã—ã¾ã—ãŸã€‚");
  }

  state.mode = 'town';

  document.getElementById('ui-town-ctrl').classList.remove('hidden');
  document.getElementById('ui-dungeon-ctrl').classList.add('hidden');
  document.getElementById('ui-battle-ctrl').classList.add('hidden');
  document.getElementById('battle-hud').classList.add('hidden');

  showTab('town');
   updateUI();
   refreshShop();

    // âœ… åˆå›ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³ã‚¯ãƒªã‚¢ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆæ¿æ©‹ã‚¤ãƒ™ãƒ³ãƒˆï¼‰ãƒã‚§ãƒƒã‚¯
    // èµ¤å¡šå…¬åœ’ã‚’åˆã‚ã¦ã‚¯ãƒªã‚¢ã—ãŸã‚ã¨ã€å¸°é‚„æ™‚ã«ã‚¤ãƒ™ãƒ³ãƒˆã‚’ç™ºç«ã™ã‚‹
    maybeTriggerItabashiEvent();

    // âœ… é«˜å³¶å¹³ã‚¯ãƒªã‚¢å¾Œã‚¤ãƒ™ãƒ³ãƒˆãƒã‚§ãƒƒã‚¯
    // é«˜å³¶å¹³ã‚’åˆã‚ã¦ã‚¯ãƒªã‚¢ã—ãŸã‚ã¨ã€å¸°é‚„æ™‚ã«ã‚¤ãƒ™ãƒ³ãƒˆã‚’ç™ºç«ã™ã‚‹
    maybeTriggerTakashimadairaEvent();
}

  function refreshShop() {
    const container = document.getElementById('shop-items');
    if (!container) return;

    ensureDefaultBagOwned();
    ensureEquipState();

    container.innerHTML = '';

    const equippedSet = getEquippedGearIdSet();

    BASE_SHOP_ITEMS.forEach(item => {
      const isUnlocked = state.population >= (item.req || 0);
      const isOwned = state.inventory.some(i => i.id === item.id);
      const isBag = item.category === 'bag';

      let btnClass = "btn-action w-full flex justify-between items-center";
      let labelRight = '';
      let onclick = '';

      if (isBag) {
        const isEquipped = (state.player.bagId === item.id);

        if (!isUnlocked) {
          btnClass += " disabled";
          labelRight = `äººå£${item.req}å¿…è¦`;
          onclick = "void(0)";
        } else if (!isOwned) {
          if (state.money < item.price) btnClass += " disabled";
          labelRight = `${item.price}G`;
          onclick = `buyItem('${item.id}')`;
        } else {
          labelRight = isEquipped ? "è£…å‚™ä¸­" : "æ‰€æŒ(ã‚¿ãƒƒãƒ—ã§è£…å‚™)";
          onclick = `equipBag('${item.id}')`;
        }

        const leftText = `${item.icon} ${item.name}ï¼ˆå®¹é‡${item.cap}ï¼‰`;
        const div = document.createElement('div');
        div.innerHTML = `<button onclick="${onclick}" class="${btnClass}">
          <span>${leftText}</span>
          <span>${labelRight}</span>
        </button>`;
        container.appendChild(div);
        return;
      }

      const isEquipped = equippedSet.has(item.id);

      if (!isUnlocked) {
        btnClass += " disabled";
        labelRight = `äººå£${item.req}å¿…è¦`;
        onclick = "void(0)";
      } else if (!isOwned) {
        if (state.money < item.price) btnClass += " disabled";
        labelRight = `${item.price}G`;
        onclick = `buyItem('${item.id}')`;
      } else {
        labelRight = isEquipped ? "è£…å‚™ä¸­(è§£é™¤)" : "æ‰€æŒ(è£…å‚™)";
        onclick = `toggleEquipGear('${item.id}')`;
      }

      const leftText = `${item.icon} ${item.name}`;
      const div = document.createElement('div');
      div.innerHTML = `<button onclick="${onclick}" class="${btnClass}">
        <span>${leftText}</span>
        <span>${labelRight}</span>
      </button>`;
      container.appendChild(div);
    });
  }

  function buyItem(id) {
    const item = BASE_SHOP_ITEMS.find(i => i.id === id);
    if (!item) return;

    const isOwned = state.inventory.some(i => i.id === id);
    if (isOwned) return;

    if (state.money >= (item.price || 0)) {
      state.money -= (item.price || 0);
      state.inventory.push({ id: id, plus: 0 });

      if (item.category === 'bag') {
        state.player.bagId = id;
        updateLootMaxFromBag();
        logMessage(`è³¼å…¥ï¼†è£…å‚™ï¼š${item.name}ï¼ˆå®¹é‡ ${item.cap}ï¼‰`);
      } else {
        logMessage(`è³¼å…¥ï¼š${item.name}`);
      }

      updateUI();
      refreshShop();
    }
  }

  function buyUpgrade(type) {
  if (type === 'park') {
    if (state.money < 1000) { openModal("è³‡é‡‘ãŒè¶³ã‚Šã¾ã›ã‚“ã€‚"); return; }
    state.money -= 1000;
    state.stats.env = Math.min(100, state.stats.env + 20);
    logMessage("â›² å…¬åœ’æ•´å‚™ï¼šç’°å¢ƒãŒæ”¹å–„ã—ãŸï¼");
    addTrust(2, "å…¬åœ’æ•´å‚™");
  } else if (type === 'medical') {
    if (state.money < 2500) { openModal("è³‡é‡‘ãŒè¶³ã‚Šã¾ã›ã‚“ã€‚"); return; }
    state.money -= 2500;
    state.stats.health = Math.min(100, state.stats.health + 20);
    logMessage("ğŸ’Š åŒ»ç™‚æŠ•è³‡ï¼šå¥åº·ãŒæ”¹å–„ã—ãŸï¼");
    addTrust(2, "åŒ»ç™‚æŠ•è³‡");
  }

  updateUI();
  saveGame();
}
  function recruitStaff() {
    if (state.money >= state.staffCost) {
      state.money -= state.staffCost;
      state.staff++;
      state.staffCost = Math.floor(state.staffCost * 1.4);
      logMessage("ğŸ§¹ æ¸…æƒå“¡ã‚’é›‡ç”¨ã—ãŸï¼");
      updateUI();
    }
  }

  function useDrink() {
    const ps = getPlayerStats();
    if (state.player.drinks > 0 && state.player.hp < ps.maxHp) {
      state.player.drinks--;
      state.player.hp = Math.min(ps.maxHp, state.player.hp + 100);
      updateUI();
    }
  }

  function logMessage(m) {
    const el = document.getElementById('game-log');
    if (el) el.innerText = m;
  }

  function createFloatingText(t, c, x) {
    const div = document.createElement('div');
    div.innerText = t;
    div.className = 'floating-text';
    div.style.left = `${x}%`;
    div.style.top = `40%`;
    div.style.color = c;
    document.getElementById('screen-container').appendChild(div);
    setTimeout(() => div.remove(), 1200);
  }

  function openModal(txt) {
    document.getElementById('modal-text').innerText = txt;
    document.getElementById('custom-modal').style.display = 'flex';
  }
  function closeModal() {
    document.getElementById('custom-modal').style.display = 'none';
  }

  function useNationalSupport() {
  ensureCollapseState();

  // âœ… å´©å£Šä¸­ã ã‘ä½¿ç”¨å¯èƒ½
  if (!state.collapse.active) {
    openModal("ğŸ› å›½æ°‘ç·æ”¯æ´ã¯ã€ä¸–ç•Œå´©å£Šãƒ•ã‚§ãƒ¼ã‚ºä¸­ã€ã«ã®ã¿ä½¿ç”¨ã§ãã¾ã™ã€‚");
    return;
  }

  const now = Date.now();

  // âœ… é€£æ‰“æŠ‘åˆ¶ï¼ˆå¥½ã¿ã§å¤‰æ›´OKï¼‰
  const COOLDOWN_MS = 8000;
  if (state._nationalSupportCdUntil && now < state._nationalSupportCdUntil) {
    const left = Math.ceil((state._nationalSupportCdUntil - now) / 1000);
    logMessage(`ğŸ› å›½æ°‘ç·æ”¯æ´ã¯æº–å‚™ä¸­â€¦ï¼ˆã‚ã¨${left}sï¼‰`);
    return;
  }
  state._nationalSupportCdUntil = now + COOLDOWN_MS;

  // âœ… åŠ¹æœï¼šä¸€å®šæ™‚é–“ã€å´©å£Šæ‚ªåŒ–ã‚’å¼±ã‚ã‚‹ï¼ˆæŠ‘åˆ¶ï¼‰
  const DURATION_MS = 15000; // 15ç§’ï¼ˆå¥½ã¿ã§èª¿æ•´OKï¼‰
  state.collapse.supportUntil = Math.max(state.collapse.supportUntil || 0, now + DURATION_MS);

  // âœ… å³æ™‚å›å¾©ï¼šæœ€ä½é™ã®æŒã¡ç›´ã—
  state.stats.env      = clamp(state.stats.env + 8, 0, 100);
  state.stats.security = clamp(state.stats.security + 8, 0, 100);
  state.stats.health   = clamp(state.stats.health + 8, 0, 100);

  // âœ… ã‚´ãƒŸåœ§ç¸®ï¼šå‰²åˆã§å°‘ã—æ¸›ã‚‰ã™ï¼ˆå·¨å¤§å€¤ã§ã‚‚åŠ¹ãï¼‰
  const before = state.wasteRate ?? 0;
  const after  = Math.max(0, before * 0.92); // 8%åœ§ç¸®
  state.wasteRate = after;

  logMessage("ğŸ› å›½æ°‘ç·æ”¯æ´ï¼ å´©å£ŠãŒä¸€æ™‚çš„ã«æŠ‘åˆ¶ã•ã‚Œã€è¡—ãŒæŒã¡ç›´ã—ãŸï¼");
  updateUI();
  saveGame();
}
  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const env = state.stats.env / 100;
    ctx.fillStyle = `rgb(${40 - (env * 20)}, ${50 + (env * 50)}, ${80 + (env * 50)})`;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.fillStyle = '#0d0d0d';
    ctx.fillRect(0, 160, canvas.width, 40);

    const px = Math.floor(canvas.width * 0.55);
    const py = 200 - 40 - (PLAYER_SPR.ready ? (PLAYER_SPR.frameH * PLAYER_SPR.scale) : 0) + 18;

    if (state.mode === 'town') {
      drawTownTiles();
      drawPlayerFrame(0, px, py);
    } else if (state.mode === 'dungeon') {
      ctx.fillStyle = "rgba(0,0,0,0.25)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      drawPlayerFrame(getPlayerFrame(), px, py);
    } else if (state.mode === 'battle' && state.enemy) {
      ctx.fillStyle = "rgba(0,0,0,0.25)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      drawEnemySprite(state.enemy, canvas.width * 0.30, 105);
      drawPlayerFrame(getPlayerFrame(), px, py);
    }
  }

  function gameLoop() {
    draw();
    requestAnimationFrame(gameLoop);
  }

  const GACHA_COST = 500;

  const GACHA_POOL = [
    { masterId: "yuzuki",   weight: 50 },
    { masterId: "mirako",   weight: 45 },
    { masterId: "fromzero", weight: 5  }
  ];

  function rollRarity() {
    const r = Math.random();
    if (r < 0.02) return 5;
    if (r < 0.08) return 4;
    if (r < 0.23) return 3;
    if (r < 0.50) return 2;
    return 1;
  }

  function weightedPick(pool) {
    const sum = pool.reduce((a,b)=>a+b.weight,0);
    let r = Math.random() * sum;
    for (const p of pool) { r -= p.weight; if (r <= 0) return p.masterId; }
    return pool[pool.length-1].masterId;
  }

  function openGachaModal() {
    ensureSupportState();
    document.getElementById("gacha-modal").style.display = "flex";
    document.getElementById("gacha-result").innerText = "çµæœã¯ã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™";
  }
  function closeGachaModal() {
    document.getElementById("gacha-modal").style.display = "none";
  }

  function openSupportModal() {
    ensureSupportState();
    renderSupportUI();
    document.getElementById("support-modal").style.display = "flex";
  }
  function closeSupportModal() {
    document.getElementById("support-modal").style.display = "none";
  }

  function autoEquipIfEmpty(uid) {
    const s = state.supports.slots;
    if (!s.slot1) { s.slot1 = uid; return true; }
    if (!s.slot2) { s.slot2 = uid; return true; }
    if (!s.slot3) { s.slot3 = uid; return true; }
    return false;
  }

  function doGachaOnce() {
    ensureSupportState();

    if (state.money < GACHA_COST) {
      document.getElementById("gacha-result").innerText = "è³‡é‡‘ãŒè¶³ã‚Šã¾ã›ã‚“ã€‚";
      return;
    }
    state.money -= GACHA_COST;

    const masterId = weightedPick(GACHA_POOL);
    const rarity = rollRarity();

    const existing = state.supports.inventory.find(u =>
      u.masterId === masterId && u.rarity === rarity
    );

    const m = SUPPORT_MASTER[masterId];

    const rate = DUPE_RATE[rarity] ?? 0;
    const ratePct = Math.round(rate * 100);

    if (existing) {
      existing.dupes = (existing.dupes ?? 0) + 1;

      document.getElementById("gacha-result").innerHTML =
        `${rarityBadgeHTML(rarity, existing.dupes)} ${m.icon} ${m.name} ãŒãƒ€ãƒ–ã‚Šã¾ã—ãŸï¼<br>` +
        `è‡ªç„¶å¼·åŒ–ï¼šå…¨èƒ½åŠ› <b>+${ratePct}%</b>ï¼ˆç´¯è¨ˆï¼š${ratePct}% Ã— ${existing.dupes}ï¼‰`;
    } else {
      const uid = `s_${masterId}_${Date.now().toString(36)}_${Math.floor(Math.random()*999)}`;

      state.supports.inventory.push({
        uid, masterId, rarity, level: 1, exp: 0, dupes: 0
      });

      const equipped = autoEquipIfEmpty(uid);

      document.getElementById("gacha-result").innerHTML =
        `${rarityBadgeHTML(rarity, 0)} ${m.icon} ${m.name} ã‚’å…¥æ‰‹ï¼${equipped ? "ï¼ˆè‡ªå‹•è£…å‚™ï¼‰" : ""}`;
    }

    saveGame();
    updateUI();
    if (document.getElementById("support-modal").style.display === "flex") renderSupportUI();
  }

  function renderSupportUI() {
    ensureSupportState();
    const slots = state.supports.slots;

    const nameOf = (uid)=>{
      if (!uid) return "-";
      const u = getSupportUnit(uid);
      if (!u) return "-";
      const m = SUPPORT_MASTER[u.masterId];
      const dupes = u.dupes ?? 0;
      return `${rarityText(u.rarity, dupes)} ${m.icon}${m.name}`;
    };

    document.getElementById("eq1").innerText = nameOf(slots.slot1);
    document.getElementById("eq2").innerText = nameOf(slots.slot2);
    document.getElementById("eq3").innerText = nameOf(slots.slot3);

    const list = document.getElementById("support-list");
    list.innerHTML = "";

    if (!state.supports.inventory.length) {
      list.innerHTML = `<div class="text-[10px] text-gray-300 border border-white/20 bg-black/30 p-2">
        ã¾ã ã‚µãƒãƒ¼ãƒˆãŒã„ã¾ã›ã‚“ã€‚<b>ã‚¬ãƒãƒ£</b>ã§å…¥æ‰‹ã—ã¦ãã ã•ã„ã€‚
      </div>`;
      return;
    }

    for (const u of state.supports.inventory.slice().reverse()) {
      const m = SUPPORT_MASTER[u.masterId];
      if (!m) continue;

      const isEq = Object.values(slots).includes(u.uid);

      const wrap = document.createElement("div");
      wrap.className = "border border-white/20 bg-black/30 p-2";

      const dupes = u.dupes ?? 0;
      const pct = Math.round((DUPE_RATE[u.rarity] ?? 0) * 100);

      wrap.innerHTML = `
        <div class="flex justify-between items-center">
          <div class="text-xs">
            ${rarityBadgeHTML(u.rarity, dupes)} ${m.icon} <b>${m.name}</b> Lv.${u.level}
            ${isEq ? `<span class="text-green-400">ï¼ˆè£…å‚™ä¸­ï¼‰</span>` : ``}
            <div class="text-[10px] text-gray-300 mt-1">
              ã‚¹ã‚­ãƒ«ï¼š<b>${getSupportSkillDisplayName(u)}</b>
            </div>
            <div class="text-[10px] text-gray-300 mt-1">
              ãƒ€ãƒ–ã‚Šå¼·åŒ–ï¼šå…¨èƒ½åŠ› +${pct}% Ã— ${dupes}
            </div>
          </div>
        </div>
        <div class="grid grid-cols-3 gap-2 mt-2">
          <button class="btn-action" onclick="equipSupportToSlot('${u.uid}','slot1')">â‘ è£…å‚™</button>
          <button class="btn-action" onclick="equipSupportToSlot('${u.uid}','slot2')">â‘¡è£…å‚™</button>
          <button class="btn-action" onclick="equipSupportToSlot('${u.uid}','slot3')">â‘¢è£…å‚™</button>
        </div>
      `;
      list.appendChild(wrap);
    }
  }

  function equipSupportToSlot(uid, slotKey) {
    ensureSupportState();
    const u = getSupportUnit(uid);
    if (!u) return;

    state.supports.slots[slotKey] = uid;
    saveGame();
    updateUI();
    renderSupportUI();
  }

  /* -------------------------------------------------------------------
     âœ… åˆå›ãƒ—ãƒ¬ã‚¤å°å…¥ã‚¤ãƒ™ãƒ³ãƒˆï¼šæ¡ˆå†…å½¹ã€Œæ¿æ©‹ã€ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
     ------------------------------------------------------------------- */
  // å°å…¥ã‚¹ãƒˆãƒ¼ãƒªãƒ¼ã¨ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å†…å®¹
  var introStoryMessages = [
    "ã‚„ãã€‚ä¿ºã¯æ¡ˆå†…å½¹ã®ã€Œæ¿æ©‹ã€ã€‚ã‚ˆã‚ã—ããªã€‚",
    "ã“ã“ã¯ã€å°‘ã—ãšã¤ã‚´ãƒŸãŒæºœã¾ã£ã¦ã—ã¾ã£ãŸåœ°åŸŸã ã€‚\næ”¾ã£ã¦ãŠãã¨ã€ç’°å¢ƒã‚‚ã€æ²»å®‰ã‚‚ã€\näººã®æ°—æŒã¡ã‚‚â€¦â€¦å°‘ã—ãšã¤è’ã‚Œã¦ã„ãã€‚",
    "ã•ã¦ã€‚\nå›ã¯ã‚´ãƒŸæ‹¾ã„ã«é–¢å¿ƒãŒã‚ã‚‹ã‚ˆã†ã ãŒã€ã©ã†ã ã‚ã†ã€‚\nä¿ºã¨ä¸€ç·’ã«ã€ã‚´ãƒŸæ‹¾ã„æ´»å‹•ã‚’ã—ãªãŒã‚‰\nã“ã®åœ°åŸŸã‚’ã€ã‚‚ã†ä¸€åº¦ãã‚Œã„ã«ã—ã¦ã¿ãªã„ã‹ï¼Ÿ",
    "ä»Šå›ã¯â€¦â€¦ä¸Šæ‰‹ãã„ãã¨ã„ã„ãªã€‚",
    "â€¦â€¦ã‚ã€ã„ã‚„ã€‚\nãªã‚“ã§ã‚‚ãªã„ã€‚æ°—ã«ã—ãªã„ã§ãã‚Œã€‚"
  ];
  // ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«èª¬æ˜ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å†…å®¹
  var introTutorialMessages = [
    "ã•ã¦ã€ã›ã£ã‹ãã ã‹ã‚‰\nå°‘ã—ã ã‘èª¬æ˜ã—ã¦ãŠã“ã†ã€‚",
    "ã“ã®ã‚²ãƒ¼ãƒ ã§ã¯ãªã€\nã€Œã‚´ãƒŸã‚’æ‹¾ã†ã€ã“ã¨ã§è³‡é‡‘ãŒæ‰‹ã«å…¥ã‚‹ã€‚\nã¾ãšã¯ç”»é¢ä¸‹ã®ã€Œé å¾ã€ã‹ã‚‰èµ¤å¡šå…¬åœ’ã¸è¡Œã£ã¦ã¿ã¦ãã‚Œã€‚",
    "æ‹¾ã£ãŸè³‡é‡‘ã¯ã€Œè¡—ã¥ãã‚Šã€ã§ä½¿ãˆã‚‹ã€‚\nç’°å¢ƒã‚’è‰¯ãã™ã‚Œã°äººã¯å¢—ãˆã‚‹ã—ã€\næ²»å®‰ã‚„å¥åº·ã‚‚å¤§äº‹ã ã€‚",
    "ã©ã‚Œã‹ä¸€ã¤ã§ã‚‚æ”¾ã£ã¦ãŠãã¨â€¦â€¦\nè¡—ã¯ã€å°‘ã—ãšã¤å£Šã‚Œã¦ã„ãã€‚",
    "ã¾ã‚ã€é›£ã—ãè€ƒãˆãªãã¦ã„ã„ã€‚\nå›°ã£ãŸã‚‰ã€ã¾ãŸä¿ºãŒå£°ã‚’ã‹ã‘ã‚‹ã€‚",
    "ãã‚Œã˜ã‚ƒã€è¡Œã“ã†ã‹ã€‚"
  ];
  // ç¾åœ¨ã®è¡¨ç¤ºã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãŠã‚ˆã³ã‚¹ãƒ†ãƒ¼ã‚¸ (0=å°å…¥, 1=ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«)
  var introStage = 0;
  var introIndex = 0;
  // ç¾åœ¨è¡¨ç¤ºä¸­ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é…åˆ—
  var introMessages = [];

  // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦å¿…è¦ãªã‚‰ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’è¡¨ç¤º
  function showIntroIfNeeded() {
    // ã™ã§ã«ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ã¾ã§çµ‚äº†ã—ã¦ã„ã‚Œã°ä½•ã‚‚ã—ãªã„
    if (localStorage.getItem('introTutorialShown')) {
      return;
    }
    // æ—§ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®ãƒ•ãƒ©ã‚°ãŒã‚ã‚‹å ´åˆã¯å°å…¥æ¸ˆã¿ã¨ã—ã¦æ‰±ã†
    if (localStorage.getItem('introGuideShown') && !localStorage.getItem('introStoryShown')) {
      localStorage.setItem('introStoryShown', 'true');
    }
    var modal = document.getElementById('intro-modal');
    if (!modal) return;
    // ã‚¹ãƒˆãƒ¼ãƒªãƒ¼ãŒã¾ã ãªã‚‰å°å…¥ã‹ã‚‰ã€æ—¢ã«çµ‚ã‚ã£ã¦ã„ã‚Œã°ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ã‹ã‚‰é–‹å§‹
    if (!localStorage.getItem('introStoryShown')) {
      introStage = 0;
      introMessages = introStoryMessages;
    } else {
      introStage = 1;
      introMessages = introTutorialMessages;
    }
    introIndex = 0;
    updateIntroText();
    modal.style.display = 'flex';
    modal.addEventListener('click', advanceIntro);
  }

  // ç¾åœ¨ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤ºã‚¨ãƒªã‚¢ã«åæ˜ 
  function updateIntroText() {
    var textEl = document.getElementById('intro-text');
    if (!textEl) return;
    var msg = introMessages[introIndex] || "";
    textEl.innerHTML = msg.replace(/\n/g, "<br>");
  }

  // æ¬¡ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¸é€²ã‚ã‚‹å‡¦ç†
  function advanceIntro() {
    introIndex++;
    // é…åˆ—ã‚’æœ€å¾Œã¾ã§è¡¨ç¤ºã—ãŸå ´åˆã®å‡¦ç†
    if (introIndex >= introMessages.length) {
      if (introStage === 0) {
        // å°å…¥ã‚¹ãƒˆãƒ¼ãƒªãƒ¼çµ‚äº†
        localStorage.setItem('introStoryShown', 'true');
        // ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ãŒæœªè¡¨ç¤ºãªã‚‰é–‹å§‹
        if (!localStorage.getItem('introTutorialShown')) {
          introStage = 1;
          introMessages = introTutorialMessages;
          introIndex = 0;
          updateIntroText();
          return;
        }
      } else {
        // ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«çµ‚äº†
        localStorage.setItem('introTutorialShown', 'true');
      }
      // å…¨ã¦çµ‚äº†ã—ãŸã®ã§ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
      var modal = document.getElementById('intro-modal');
      if (modal) {
        modal.style.display = 'none';
        modal.removeEventListener('click', advanceIntro);
      }
      return;
    }
    updateIntroText();
  }

  // =========================================================
  // âœ… èµ¤å¡šå…¬åœ’ã‚¯ãƒªã‚¢å¾Œã‚¤ãƒ™ãƒ³ãƒˆï¼ˆæ¿æ©‹ã‚¤ãƒ™ãƒ³ãƒˆï¼‰
  // =========================================================
  // ã‚»ãƒªãƒ•å†…å®¹ï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒã‚¿ãƒƒãƒ—ã§é€²ã‚ã‚‹ï¼‰
  var itabashiMessages = [
    'â€¦â€¦ã‚„ã‚ã€‚',
    'èµ¤å¡šå…¬åœ’ã®æ§˜å­ã¯ã€ã¡ã‚ƒã‚“ã¨è¦‹ã¦ã„ãŸã€‚',
    'æœ€åˆã¯æ­£ç›´ã€\nã€Œç¶šã‹ãªã„ã ã‚ã†ã€ã¨æ€ã£ã¦ã„ãŸã€‚',
    'ã ãŒã€æ•°å­—ãŒå¤‰ã‚ã£ãŸã€‚\näººã®å‹•ãã‚‚ã€è¡—ã®åå¿œã‚‚ã ã€‚',
    'â€¦â€¦ã„ã‚„ã€‚\nä»Šã®ã¯é•ã†ãªã€‚',
    'æ•°å­—ã‚ˆã‚Šå…ˆã«ã€\nç©ºæ°—ãŒå¤‰ã‚ã£ãŸã€‚',
    'å›ãŒæ‹¾ã£ãŸæœ€å¾Œã®ã‚´ãƒŸã€‚\nã‚ã‚ŒãŒã€ä¸€ç•ªåŠ¹ã„ãŸã€‚',
    'å¿˜ã‚Œã¦ãã‚Œã€‚\nãŸã ã®è¦³æ¸¬çµæœã ã€‚',
    'èµ¤å¡šå…¬åœ’ã¯ã€ã‚‚ã†å¤§ä¸ˆå¤«ã ã€‚\nã“ã“ã¯â€œå§‹ã¾ã‚Šâ€ã¨ã—ã¦ã¯ã€ä¸Šå‡ºæ¥ã ã€‚',
    'ã ãŒæ¬¡ã¯é•ã†ã€‚',
    'äººã‚‚å¤šãã€\nç†ç”±ã‚’æŠ±ãˆãŸã‚´ãƒŸãŒé›†ã¾ã‚‹å ´æ‰€ã€‚',
    'é«˜å³¶å¹³ã€‚',
    'ã‚ãã“ã‚’å¤‰ãˆã‚‰ã‚Œã‚‹ã‹ã©ã†ã‹ã§ã€\nã“ã®è¡—ã®æœªæ¥ã¯æ±ºã¾ã‚‹ã€‚',
    'â€¦â€¦è¡Œãè¦šæ‚Ÿã¯ã‚ã‚‹ã‹ï¼Ÿ'
  ];
  var itabashiIndex = 0;

  // æ¿æ©‹ã‚¤ãƒ™ãƒ³ãƒˆã‚’é–‹å§‹ã™ã‚‹
  function triggerItabashiEvent() {
    // ã™ã§ã«å®Ÿè¡Œæ¸ˆã¿ãªã‚‰ä½•ã‚‚ã—ãªã„
    if (state.flags?.itabashiEventDone) return;
    itabashiIndex = 0;
    updateItabashiText();
    var modal = document.getElementById('itabashi-modal');
    if (!modal) return;
    // æœ€åˆã¯ã‚¿ãƒƒãƒ—èª¬æ˜ã‚’è¡¨ç¤ºã—ã€é¸æŠè‚¢ã‚’éè¡¨ç¤ºã«ã™ã‚‹
    var tapEl = document.getElementById('itabashi-tap');
    var choicesEl = document.getElementById('itabashi-choices');
    if (tapEl) tapEl.style.display = '';
    if (choicesEl) choicesEl.style.display = 'none';
    modal.style.display = 'flex';
    // ã‚¿ãƒƒãƒ—ã§æ¬¡ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¸
    modal.addEventListener('click', advanceItabashi);
  }

  // æ¿æ©‹ã‚¤ãƒ™ãƒ³ãƒˆã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ç”»é¢ã«åæ˜ 
  function updateItabashiText() {
    var textEl = document.getElementById('itabashi-text');
    if (!textEl) return;
    var msg = itabashiMessages[itabashiIndex] || '';
    textEl.innerHTML = msg.replace(/\n/g, '<br>');
  }

  // æ¿æ©‹ã‚¤ãƒ™ãƒ³ãƒˆã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€²ã‚ã‚‹
  function advanceItabashi() {
    itabashiIndex++;
    // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é…åˆ—ã‚’æœ€å¾Œã¾ã§è¡¨ç¤ºã—ãŸå ´åˆ
    if (itabashiIndex >= itabashiMessages.length) {
      var modal = document.getElementById('itabashi-modal');
      if (!modal) return;
      // ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆè§£é™¤
      modal.removeEventListener('click', advanceItabashi);
      // ã‚¿ãƒƒãƒ—æ¡ˆå†…ã‚’éè¡¨ç¤ºã«ã—ã¦é¸æŠè‚¢ã‚’è¡¨ç¤º
      var tapEl = document.getElementById('itabashi-tap');
      var choicesEl = document.getElementById('itabashi-choices');
      if (tapEl) tapEl.style.display = 'none';
      if (choicesEl) {
        choicesEl.style.display = 'block';
        var btn1 = document.getElementById('itabashi-choice-1');
        var btn2 = document.getElementById('itabashi-choice-2');
        if (btn1) {
          btn1.innerText = 'è¡Œã';
          btn1.onclick = function() { completeItabashiEvent(); };
        }
        if (btn2) {
          btn2.innerText = 'å°‘ã—è€ƒãˆãŸã„';
          btn2.onclick = function() { completeItabashiEvent(); };
        }
      }
      return;
    }
    updateItabashiText();
  }

  // æ¿æ©‹ã‚¤ãƒ™ãƒ³ãƒˆã®å®Œäº†å‡¦ç†
  function completeItabashiEvent() {
    var modal = document.getElementById('itabashi-modal');
    if (modal) {
      // å¿µã®ãŸã‚ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆã‚’è§£é™¤
      modal.removeEventListener('click', advanceItabashi);
      modal.style.display = 'none';
    }
    // ãƒ•ãƒ©ã‚°æ›´æ–°ï¼šã‚¤ãƒ™ãƒ³ãƒˆå®Œäº†
    if (!state.flags) state.flags = {};
    state.flags.itabashiEventDone = true;
    // ä¿¡é ¼ã‚²ãƒ¼ã‚¸ä¸Šé™ã‚’50ã«æ‹¡å¼µï¼ˆåˆæœŸ25ã®å ´åˆã®ã¿é©ç”¨ã€ç¹°ã‚Šè¿”ã—ã‚¯ãƒªã‚¢ã§ã‚‚ç¶­æŒï¼‰
    state.trustMax = Math.max(state.trustMax || 0, 50);
    // UIæ›´æ–°ãŠã‚ˆã³ä¿å­˜
    updateUI();
    saveGame();
    // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æ®‹ã™ï¼ˆä»»æ„ï¼‰
    logMessage('é«˜å³¶å¹³ãŒè§£æ”¾ã•ã‚Œã¾ã—ãŸï¼');
  }

  // èµ¤å¡šå…¬åœ’ã‚¯ãƒªã‚¢å¾Œã‚¤ãƒ™ãƒ³ãƒˆã®ç™ºç«åˆ¤å®š
  function maybeTriggerItabashiEvent() {
    // ã‚¯ãƒªã‚¢æ¸ˆã¿ã‹ã¤ã¾ã ã‚¤ãƒ™ãƒ³ãƒˆã‚’ã‚„ã£ã¦ã„ãªã„å ´åˆã«ç™ºç«
    if (state?.cleared?.akatsuka && !state.flags?.itabashiEventDone) {
      // å°‘ã—é…å»¶ã•ã›ã¦ãƒ­ã‚°è¡¨ç¤ºã¨è¢«ã‚‰ãªã„ã‚ˆã†ã«ã™ã‚‹
      setTimeout(() => { triggerItabashiEvent(); }, 600);
    }
  }

  // =========================================================
  // é«˜å³¶å¹³ã‚¯ãƒªã‚¢å¾Œã‚¤ãƒ™ãƒ³ãƒˆï¼ˆè’å·è§£æ”¾ã‚¤ãƒ™ãƒ³ãƒˆï¼‰
  // =========================================================
  // é«˜å³¶å¹³ã‚¯ãƒªã‚¢æ™‚ã«ä¸€åº¦ã ã‘ç™ºç”Ÿã™ã‚‹æ¿æ©‹ã‚¤ãƒ™ãƒ³ãƒˆã®å¾Œç¶šã‚¤ãƒ™ãƒ³ãƒˆã§ã™ã€‚
  let takashimadairaIndex = 0;
  const takashimadairaMessages = [
    "â€¦â€¦ã‚ˆãã‚„ã£ãŸã€‚",
    "é«˜å³¶å¹³ã¯ã€èµ¤å¡šã¨é•ã†ã€‚äººã‚‚å¤šã„åˆ†ã€è«¦ã‚ã‚‚å¤šã„ã€‚",
    "ãã‚Œã§ã‚‚å›ã¯ã€æ‰‹ã‚’æ­¢ã‚ãªã‹ã£ãŸã€‚",
    "è¡—ã¯ã€ã“ã†ã„ã†æ™‚ã«â€œé¸ã¶â€ã€‚",
    "â€¦â€¦èª°ã‚’ä¿¡ã˜ã‚‹ã‹ã‚’ã€‚",
    "å›ãŒã“ã“ã§æ‹¾ã£ãŸã‚‚ã®ã¯ã€ã‚´ãƒŸã ã‘ã˜ã‚ƒãªã„ã€‚",
    "ã€ç¶šã‘ã‚‰ã‚Œã‚‹ã€ã¨ã„ã†è¨¼æ˜ã ã€‚",
    "æ¬¡ã¯â”€â”€è’å·ã€‚ã‚ãã“ã¯è¡—ã®ç«¯ã˜ã‚ƒãªã„ã€‚è¡—ã®â€œå‡ºå£â€ã ã€‚",
    "æµã‚Œå‡ºãŸã‚‚ã®ã¯ã€æˆ»ã‚‰ãªã„ã€‚ã ã‹ã‚‰æœ€å¾Œã«æ®‹ã‚‹ã€‚",
    "â€¦â€¦è¡Œãã‹ï¼Ÿ"
  ];

  function triggerTakashimadairaEvent() {
    // ã™ã§ã«å®Ÿè¡Œæ¸ˆã¿ãªã‚‰ä½•ã‚‚ã—ãªã„
    if (state.flags?.takashimadairaEventDone) return;
    takashimadairaIndex = 0;
    updateTakashimadairaText();
    const modal = document.getElementById('itabashi-modal');
    if (!modal) return;
    // ä½¿ã„å›ã—ï¼šæœ€åˆã¯ã‚¿ãƒƒãƒ—èª¬æ˜ã‚’è¡¨ç¤ºã—ã€é¸æŠè‚¢ã‚’éè¡¨ç¤ºã«ã™ã‚‹
    const tapEl = document.getElementById('itabashi-tap');
    const choicesEl = document.getElementById('itabashi-choices');
    if (tapEl) tapEl.style.display = '';
    if (choicesEl) choicesEl.style.display = 'none';
    modal.style.display = 'flex';
    // ã‚¿ãƒƒãƒ—ã§æ¬¡ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¸
    modal.addEventListener('click', advanceTakashimadaira);
  }

  // é«˜å³¶å¹³ã‚¤ãƒ™ãƒ³ãƒˆã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸åæ˜ 
  function updateTakashimadairaText() {
    const textEl = document.getElementById('itabashi-text');
    if (!textEl) return;
    const msg = takashimadairaMessages[takashimadairaIndex] || '';
    textEl.innerHTML = msg.replace(/\n/g, '<br>');
  }

  // é«˜å³¶å¹³ã‚¤ãƒ™ãƒ³ãƒˆã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€²ã‚ã‚‹
  function advanceTakashimadaira() {
    takashimadairaIndex++;
    if (takashimadairaIndex >= takashimadairaMessages.length) {
      const modal = document.getElementById('itabashi-modal');
      if (!modal) return;
      modal.removeEventListener('click', advanceTakashimadaira);
      const tapEl = document.getElementById('itabashi-tap');
      const choicesEl = document.getElementById('itabashi-choices');
      if (tapEl) tapEl.style.display = 'none';
      if (choicesEl) {
        choicesEl.style.display = 'block';
        const btn1 = document.getElementById('itabashi-choice-1');
        const btn2 = document.getElementById('itabashi-choice-2');
        if (btn1) {
          btn1.innerText = 'è¡Œã';
          btn1.onclick = function() { completeTakashimadairaEvent(); };
        }
        if (btn2) {
          btn2.innerText = 'ä¼‘ã‚“ã§ã‹ã‚‰è¡Œã';
          btn2.onclick = function() { completeTakashimadairaEvent(); };
        }
      }
      return;
    }
    updateTakashimadairaText();
  }

  // é«˜å³¶å¹³ã‚¤ãƒ™ãƒ³ãƒˆã®å®Œäº†å‡¦ç†
  function completeTakashimadairaEvent() {
    const modal = document.getElementById('itabashi-modal');
    if (modal) {
      modal.removeEventListener('click', advanceTakashimadaira);
      modal.style.display = 'none';
    }
    if (!state.flags) state.flags = {};
    state.flags.takashimadairaEventDone = true;
    // è’å·è§£æ”¾ãƒ•ãƒ©ã‚°
    if (!state.flags) state.flags = {};
    state.flags.arakawaUnlocked = true;
    // ä¿¡é ¼ã‚²ãƒ¼ã‚¸ä¸Šé™ã‚’75ã¾ã§æ‹¡å¼µ
    state.trustMax = Math.max(state.trustMax || 0, 75);
    // ã‚¹ã‚­ãƒ«æ ã‚’+1ï¼ˆæœ€ä½3æ ï¼‰
    if (state.skillSlots == null) state.skillSlots = 2;
    state.skillSlots = Math.max(state.skillSlots + 1, 3);
    // æ–°ã‚¹ã‚­ãƒ«ãƒœã‚¿ãƒ³ã‚’è§£æ”¾
    const unBtn = document.getElementById('skill-unwavering');
    if (unBtn) unBtn.classList.remove('hidden');
    // å„ã‚²ãƒ¼ã‚¸ãƒ–ãƒ¼ã‚¹ãƒˆï¼šç’°å¢ƒãƒ»æ²»å®‰ãƒ»å¥åº·ã‚’å°‘ã—å›å¾©
    try {
      state.stats.env = clamp(state.stats.env + 10, 0, 100);
      state.stats.security = clamp(state.stats.security + 10, 0, 100);
      state.stats.health = clamp(state.stats.health + 10, 0, 100);
    } catch(e) {}
    // UIæ›´æ–°ãƒ»ä¿å­˜
    updateUI();
    saveGame();
    // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ­ã‚°
    logMessage('è’å·ãŒè§£æ”¾ã•ã‚Œã¾ã—ãŸï¼');
  }

  // å¸°é‚„æ™‚ã«é«˜å³¶å¹³ã‚¯ãƒªã‚¢å¾Œã‚¤ãƒ™ãƒ³ãƒˆã‚’ç™ºç«
  function maybeTriggerTakashimadairaEvent() {
    // é«˜å³¶å¹³ã‚¯ãƒªã‚¢æ¸ˆã¿ && ã¾ã ã‚¤ãƒ™ãƒ³ãƒˆã‚’ã—ã¦ã„ãªã„å ´åˆ
    if (state?.cleared?.takashimadaira && !state.flags?.takashimadairaEventDone) {
      setTimeout(() => { triggerTakashimadairaEvent(); }, 600);
    }
  }
  // =========================================================
  // ã‚¹ã‚­ãƒ«æ©Ÿèƒ½ã®å®Ÿè£…
  // =========================================================
  // ã‚¹ã‚­ãƒ«å®šç¾©ï¼šå„ã‚¹ã‚­ãƒ«ã®åŠ¹æœã‚’é–¢æ•°ã¨ã—ã¦å®šç¾©ã—ã¾ã™
  const SKILLS = {
    heal: {
      name: "å›å¾©",
      effect: function() {
        const ps = getPlayerStats();
        // HPã‚’30å›å¾©ï¼ˆæœ€å¤§HPã‚’è¶…ãˆãªã„ï¼‰
        state.player.hp = Math.min(ps.maxHp, state.player.hp + 30);
        logMessage("ã‚¹ã‚­ãƒ«ï¼šHPãŒ30å›å¾©ã—ãŸï¼");
      }
    },
    power: {
      name: "å¼·æ‰“",
      effect: function() {
        const ps = getPlayerStats();
        // æ”»æ’ƒåŠ›ã®1.5å€ãƒ€ãƒ¡ãƒ¼ã‚¸
        const dmg = Math.floor(ps.atk * 1.5);
        state.enemy.curH -= dmg;
        createFloatingText(`-${dmg}`, "#fff", 60);
        logMessage(`${state.enemy.n}ã«å¼·æ‰“ï¼`);
      }
    },
    // ğŸ–ï¸ æ–°ã‚¹ã‚­ãƒ«ï¼šè«¦ã‚ãªã„æ„æ€ï¼ˆæ¯ã‚¿ãƒ¼ãƒ³HPãŒ50å›å¾©Ã—3ã‚¿ãƒ¼ãƒ³ï¼ã‚¯ãƒ¼ãƒ«ã‚¿ã‚¤ãƒ 3ã‚¿ãƒ¼ãƒ³ï¼‰
    unwavering: {
      name: "è«¦ã‚ãªã„æ„æ€",
      effect: function() {
        // æˆ¦é—˜ä¸­ã®ã¿æœ‰åŠ¹
        if (state.mode !== 'battle' || !state.battle) return;
        if (!state.battle.unwavering) state.battle.unwavering = { turnsLeft: 0, cooldownLeft: 0 };
        const buff = state.battle.unwavering;
        // ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ä¸­ã¾ãŸã¯æŒç¶šä¸­ã®å ´åˆã¯ä½¿ç”¨ä¸å¯
        if (buff.turnsLeft > 0 || buff.cooldownLeft > 0) {
          logMessage("è«¦ã‚ãªã„æ„æ€ã¯ã¾ã ä½¿ãˆã¾ã›ã‚“ï¼");
          return;
        }
        // ãƒãƒ•ä»˜ä¸ï¼š3ã‚¿ãƒ¼ãƒ³ã€ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³3ã‚¿ãƒ¼ãƒ³
        buff.turnsLeft = 3;
        buff.cooldownLeft = 3;
        // åŠ¹æœç™ºå‹•ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
        logMessage("ã‚¹ã‚­ãƒ«ç™ºå‹•ï¼šè«¦ã‚ãªã„æ„æ€ï¼ æ¬¡ã®3ã‚¿ãƒ¼ãƒ³ã€æ¯ã‚¿ãƒ¼ãƒ³HPãŒ50å›å¾©ã—ã¾ã™ã€‚");
      }
    }
  };

  /**
   * è«¦ã‚ãªã„æ„æ€ãƒãƒ•ã®åŠ¹æœé©ç”¨ã¨ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³é€²è¡Œã€‚
   * ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¿ãƒ¼ãƒ³é–‹å§‹æ™‚ã«å‘¼ã³å‡ºã—ã¦HPå›å¾©ã¨æ®‹ã‚Šã‚¿ãƒ¼ãƒ³ãƒ»ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ã‚’æ›´æ–°ã—ã¾ã™ã€‚
   */
  function tickUnwaveringBuff() {
    const b = state.battle?.unwavering;
    if (!b) return;
    // æŒç¶šã‚¿ãƒ¼ãƒ³ä¸­ï¼šHPã‚’50å›å¾©
    if (b.turnsLeft && b.turnsLeft > 0) {
      const ps = getPlayerStats();
      state.player.hp = Math.min(ps.maxHp, state.player.hp + 50);
      b.turnsLeft--;
      logMessage("è«¦ã‚ãªã„æ„æ€ã§HPãŒ50å›å¾©ã—ãŸï¼");
    } else if (b.cooldownLeft && b.cooldownLeft > 0) {
      // ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³é€²è¡Œ
      b.cooldownLeft--;
    }
  }

  /**
   * ã‚¹ã‚­ãƒ«é–¢é€£ã®UIã‚„ã‚¤ãƒ™ãƒ³ãƒˆã‚’åˆæœŸåŒ–ã—ã¾ã™ã€‚
   * ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¿ãƒ¼ãƒ³æ™‚ã«ã‚¹ã‚­ãƒ«ãƒœã‚¿ãƒ³ã‚’æŠ¼ã™ã¨ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‹ãã€
   * ã‚¹ã‚­ãƒ«ã‚’é¸æŠã™ã‚‹ã¨åŠ¹æœã‚’é©ç”¨ã—ãŸå¾Œã«æ•µã‚¿ãƒ¼ãƒ³ã¸ç§»è¡Œã—ã¾ã™ã€‚
   */
  function setupSkills() {
    const skillBtn = document.getElementById('btn-skill');
    const skillModal = document.getElementById('skill-modal');
    const skillCancel = document.getElementById('skill-cancel');

    // ã‚¹ã‚­ãƒ«ãƒœã‚¿ãƒ³ï¼šæˆ¦é—˜ä¸­ã‹ã¤ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¿ãƒ¼ãƒ³æ™‚ã®ã¿ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’è¡¨ç¤º
    if (skillBtn && skillModal) {
      skillBtn.addEventListener('click', () => {
        if (state.mode === 'battle' && state.battle?.isPlayerTurn && !state.battle.isAnimating) {
          skillModal.classList.remove('hidden');
        }
      });
    }

    // ã‚­ãƒ£ãƒ³ã‚»ãƒ«ãƒœã‚¿ãƒ³ï¼šãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
    if (skillCancel && skillModal) {
      skillCancel.addEventListener('click', () => {
        skillModal.classList.add('hidden');
      });
    }

    // å„ã‚¹ã‚­ãƒ«ãƒœã‚¿ãƒ³ã«åŠ¹æœã‚’å‰²ã‚Šå½“ã¦ã‚‹
    document.querySelectorAll('.skill-item').forEach((btn) => {
      btn.addEventListener('click', () => {
        const key = btn.dataset.skill;
        const skill = SKILLS[key];
        if (!skill) return;
        // æˆ¦é—˜ä¸­ã‹ã¤ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¿ãƒ¼ãƒ³ã§ãªã„å ´åˆã¯ä½•ã‚‚ã—ãªã„
        if (state.mode !== 'battle' || !state.battle?.isPlayerTurn || state.battle.isAnimating) {
          return;
        }
        // ã‚¹ã‚­ãƒ«ã‚’å®Ÿè¡Œ
        skill.effect();

        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ»æ•µã®HPã‚’æ›´æ–°ã—UIã«åæ˜ 
        const ps = getPlayerStats();
        state.player.hp = clamp(state.player.hp, 0, ps.maxHp);
        if (state.enemy) {
          state.enemy.curH = Math.max(0, state.enemy.curH);
          const enemyHpBar = document.getElementById('enemy-hp-bar');
          if (enemyHpBar && state.enemy.maxH > 0) {
            enemyHpBar.style.width = `${(state.enemy.curH / state.enemy.maxH) * 100}%`;
          }
        }

        // ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
        skillModal.classList.add('hidden');

        // æ•µãŒå€’ã‚ŒãŸå ´åˆã¯å³åº§ã«ãƒãƒˆãƒ«çµ‚äº†
        if (state.enemy && state.enemy.curH <= 0) {
          const lootBonus = Math.floor(ps.atk * 0.05) + Math.floor(ps.luk * 0.2);
          const lootReward = Math.floor(state.enemy.maxH * 0.8 + (Math.random() * 8)) + lootBonus;
          const isBoss = !!state.enemy?.isBoss;
          gainXp(state.enemy.x);
          endBattle({ won: true, lootReward, isBoss });
          updateUI();
          return;
        }

        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¿ãƒ¼ãƒ³çµ‚äº†ï¼šæ•µã‚¿ãƒ¼ãƒ³ã¸
        state.battle.isPlayerTurn = false;
        setTimeout(enemyTurn, 800);
        updateUI();
      });
    });

    // âœ… é«˜å³¶å¹³ã‚¯ãƒªã‚¢å¾Œã«è§£æ”¾ã•ã‚Œã‚‹ã‚¹ã‚­ãƒ«ãƒœã‚¿ãƒ³ã‚’è¡¨ç¤º
    const unBtn = document.getElementById('skill-unwavering');
    if (unBtn && state.flags?.takashimadairaEventDone) {
      unBtn.classList.remove('hidden');
    }
  }
  async function init() {
    loadGame();

    await loadAllAssets();
    setupPlayerSpriteMeta();

    ensureSupportState();
    ensureCollapseState();

    applyOfflineProgress();
    enableAutoSave();

    ensureDefaultBagOwned();
    updateLootMaxFromBag();
    applyTownGrowth();

    setInterval(mainLoopTick, 1000);
    gameLoop();

    showTab(state.uiTab || 'town');

    updateUI();
    refreshShop();

    // ã‚¹ã‚­ãƒ«ã®UIã¨ã‚¤ãƒ™ãƒ³ãƒˆã‚’åˆæœŸåŒ–
    try {
      setupSkills();
    } catch (e) {
      console.warn('setupSkills failed', e);
    }

    // åˆå›ãƒ—ãƒ¬ã‚¤æ™‚ã®å°å…¥ã‚¤ãƒ™ãƒ³ãƒˆã‚’è¡¨ç¤º
    // DOMãŒå®Œå…¨ã«ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã•ã‚Œã¦ã‹ã‚‰è¡¨ç¤ºã™ã‚‹ãŸã‚å°‘ã—é…å»¶ã•ã›ã‚‹
    setTimeout(() => {
      try {
        showIntroIfNeeded();
      } catch (e) {
        console.error('Failed to display intro:', e);
      }
    }, 50);
  }

  window.onload = init;

</script>

</body>
</html>